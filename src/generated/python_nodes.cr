# Generated by asdl_codegen from asdl/asdl_files/Python.asdl
require "../red_green"

module Python
  class GreenModule < RedGreen::GreenNode
    getter body : RedGreen::InternalSyntax::SyntaxList

    def initialize(body : RedGreen::InternalSyntax::SyntaxList)
      @body = body
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= body.flags
      full_width += body.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Module"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        body
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedModule.new(self, parent, position)
    end
  end

  class RedModule < RedGreen::SyntaxNode
    def initialize(green : GreenModule, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def body : RedGreen::ChildSyntaxList
      list = @green.as(GreenModule).body
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def update(body : Array(RedGreen::SyntaxNode)) : RedModule
      return self if body == body.to_a
      green = GreenModule.new(RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)))
      green.create_red(@parent, @position).as(RedModule)
    end

    def with_body(body : Array(RedGreen::SyntaxNode)) : RedModule
      update(body)
    end
  end

  class GreenInteractive < RedGreen::GreenNode
    getter body : RedGreen::InternalSyntax::SyntaxList

    def initialize(body : RedGreen::InternalSyntax::SyntaxList)
      @body = body
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= body.flags
      full_width += body.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Interactive"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        body
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedInteractive.new(self, parent, position)
    end
  end

  class RedInteractive < RedGreen::SyntaxNode
    def initialize(green : GreenInteractive, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def body : RedGreen::ChildSyntaxList
      list = @green.as(GreenInteractive).body
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def update(body : Array(RedGreen::SyntaxNode)) : RedInteractive
      return self if body == body.to_a
      green = GreenInteractive.new(RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)))
      green.create_red(@parent, @position).as(RedInteractive)
    end

    def with_body(body : Array(RedGreen::SyntaxNode)) : RedInteractive
      update(body)
    end
  end

  class GreenExpression < RedGreen::GreenNode
    getter body : RedGreen::GreenNode

    def initialize(body : RedGreen::GreenNode)
      @body = body
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= body.flags
      full_width += body.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Expression"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        body
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedExpression.new(self, parent, position)
    end
  end

  class RedExpression < RedGreen::SyntaxNode
    def initialize(green : GreenExpression, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def body : RedGreen::SyntaxNode?
      child_at(0)
    end

    def update(body : RedGreen::SyntaxNode) : RedExpression
      return self if body == body
      green = GreenExpression.new(body.green)
      green.create_red(@parent, @position).as(RedExpression)
    end

    def with_body(body : RedGreen::SyntaxNode) : RedExpression
      update(body)
    end
  end

  class GreenSuite < RedGreen::GreenNode
    getter body : RedGreen::InternalSyntax::SyntaxList

    def initialize(body : RedGreen::InternalSyntax::SyntaxList)
      @body = body
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= body.flags
      full_width += body.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Suite"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        body
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedSuite.new(self, parent, position)
    end
  end

  class RedSuite < RedGreen::SyntaxNode
    def initialize(green : GreenSuite, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def body : RedGreen::ChildSyntaxList
      list = @green.as(GreenSuite).body
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def update(body : Array(RedGreen::SyntaxNode)) : RedSuite
      return self if body == body.to_a
      green = GreenSuite.new(RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)))
      green.create_red(@parent, @position).as(RedSuite)
    end

    def with_body(body : Array(RedGreen::SyntaxNode)) : RedSuite
      update(body)
    end
  end

  class GreenFunctionDef < RedGreen::GreenNode
    getter name : String
    getter args : RedGreen::GreenNode
    getter body : RedGreen::InternalSyntax::SyntaxList
    getter decorator_list : RedGreen::InternalSyntax::SyntaxList
    getter returns : RedGreen::GreenNode?

    def initialize(name : String, args : RedGreen::GreenNode, body : RedGreen::InternalSyntax::SyntaxList, decorator_list : RedGreen::InternalSyntax::SyntaxList, returns : RedGreen::GreenNode?)
      @name = name
      @args = args
      @body = body
      @decorator_list = decorator_list
      @returns = returns
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= args.flags
      full_width += args.full_width
      flags |= body.flags
      full_width += body.full_width
      flags |= decorator_list.flags
      full_width += decorator_list.full_width
      if returns
        flags |= returns.flags
        full_width += returns.full_width
      end
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 4)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "FunctionDef"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        args
      when 1
        body
      when 2
        decorator_list
      when 3
        returns
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedFunctionDef.new(self, parent, position)
    end
  end

  class RedFunctionDef < RedGreen::SyntaxNode
    def initialize(green : GreenFunctionDef, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def name : String
      @green.as(GreenFunctionDef).name
    end

    def args : RedGreen::SyntaxNode?
      child_at(0)
    end

    def body : RedGreen::ChildSyntaxList
      list = @green.as(GreenFunctionDef).body
      RedGreen::SyntaxListNode.new(list, self, child_position(1)).child_nodes
    end

    def decorator_list : RedGreen::ChildSyntaxList
      list = @green.as(GreenFunctionDef).decorator_list
      RedGreen::SyntaxListNode.new(list, self, child_position(2)).child_nodes
    end

    def returns : RedGreen::SyntaxNode?
      child_at(3)
    end

    def update(name : String, args : RedGreen::SyntaxNode, body : Array(RedGreen::SyntaxNode), decorator_list : Array(RedGreen::SyntaxNode), returns : RedGreen::SyntaxNode?) : RedFunctionDef
      return self if name == name && args == args && body == body.to_a && decorator_list == decorator_list.to_a && returns == returns
      green = GreenFunctionDef.new(name, args.green, RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(decorator_list.map(&.green)), returns.try(&.green))
      green.create_red(@parent, @position).as(RedFunctionDef)
    end

    def with_name(name : String) : RedFunctionDef
      update(name, args, body.to_a, decorator_list.to_a, returns)
    end

    def with_args(args : RedGreen::SyntaxNode) : RedFunctionDef
      update(name, args, body.to_a, decorator_list.to_a, returns)
    end

    def with_body(body : Array(RedGreen::SyntaxNode)) : RedFunctionDef
      update(name, args, body, decorator_list.to_a, returns)
    end

    def with_decorator_list(decorator_list : Array(RedGreen::SyntaxNode)) : RedFunctionDef
      update(name, args, body.to_a, decorator_list, returns)
    end

    def with_returns(returns : RedGreen::SyntaxNode?) : RedFunctionDef
      update(name, args, body.to_a, decorator_list.to_a, returns)
    end
  end

  class GreenClassDef < RedGreen::GreenNode
    getter name : String
    getter bases : RedGreen::InternalSyntax::SyntaxList
    getter keywords : RedGreen::InternalSyntax::SyntaxList
    getter starargs : RedGreen::GreenNode?
    getter kwargs : RedGreen::GreenNode?
    getter body : RedGreen::InternalSyntax::SyntaxList
    getter decorator_list : RedGreen::InternalSyntax::SyntaxList

    def initialize(name : String, bases : RedGreen::InternalSyntax::SyntaxList, keywords : RedGreen::InternalSyntax::SyntaxList, starargs : RedGreen::GreenNode?, kwargs : RedGreen::GreenNode?, body : RedGreen::InternalSyntax::SyntaxList, decorator_list : RedGreen::InternalSyntax::SyntaxList)
      @name = name
      @bases = bases
      @keywords = keywords
      @starargs = starargs
      @kwargs = kwargs
      @body = body
      @decorator_list = decorator_list
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= bases.flags
      full_width += bases.full_width
      flags |= keywords.flags
      full_width += keywords.full_width
      if starargs
        flags |= starargs.flags
        full_width += starargs.full_width
      end
      if kwargs
        flags |= kwargs.flags
        full_width += kwargs.full_width
      end
      flags |= body.flags
      full_width += body.full_width
      flags |= decorator_list.flags
      full_width += decorator_list.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 6)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "ClassDef"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        bases
      when 1
        keywords
      when 2
        starargs
      when 3
        kwargs
      when 4
        body
      when 5
        decorator_list
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedClassDef.new(self, parent, position)
    end
  end

  class RedClassDef < RedGreen::SyntaxNode
    def initialize(green : GreenClassDef, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def name : String
      @green.as(GreenClassDef).name
    end

    def bases : RedGreen::ChildSyntaxList
      list = @green.as(GreenClassDef).bases
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def keywords : RedGreen::ChildSyntaxList
      list = @green.as(GreenClassDef).keywords
      RedGreen::SyntaxListNode.new(list, self, child_position(1)).child_nodes
    end

    def starargs : RedGreen::SyntaxNode?
      child_at(2)
    end

    def kwargs : RedGreen::SyntaxNode?
      child_at(3)
    end

    def body : RedGreen::ChildSyntaxList
      list = @green.as(GreenClassDef).body
      RedGreen::SyntaxListNode.new(list, self, child_position(4)).child_nodes
    end

    def decorator_list : RedGreen::ChildSyntaxList
      list = @green.as(GreenClassDef).decorator_list
      RedGreen::SyntaxListNode.new(list, self, child_position(5)).child_nodes
    end

    def update(name : String, bases : Array(RedGreen::SyntaxNode), keywords : Array(RedGreen::SyntaxNode), starargs : RedGreen::SyntaxNode?, kwargs : RedGreen::SyntaxNode?, body : Array(RedGreen::SyntaxNode), decorator_list : Array(RedGreen::SyntaxNode)) : RedClassDef
      return self if name == name && bases == bases.to_a && keywords == keywords.to_a && starargs == starargs && kwargs == kwargs && body == body.to_a && decorator_list == decorator_list.to_a
      green = GreenClassDef.new(name, RedGreen::InternalSyntax::SyntaxList.new(bases.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(keywords.map(&.green)), starargs.try(&.green), kwargs.try(&.green), RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(decorator_list.map(&.green)))
      green.create_red(@parent, @position).as(RedClassDef)
    end

    def with_name(name : String) : RedClassDef
      update(name, bases.to_a, keywords.to_a, starargs, kwargs, body.to_a, decorator_list.to_a)
    end

    def with_bases(bases : Array(RedGreen::SyntaxNode)) : RedClassDef
      update(name, bases, keywords.to_a, starargs, kwargs, body.to_a, decorator_list.to_a)
    end

    def with_keywords(keywords : Array(RedGreen::SyntaxNode)) : RedClassDef
      update(name, bases.to_a, keywords, starargs, kwargs, body.to_a, decorator_list.to_a)
    end

    def with_starargs(starargs : RedGreen::SyntaxNode?) : RedClassDef
      update(name, bases.to_a, keywords.to_a, starargs, kwargs, body.to_a, decorator_list.to_a)
    end

    def with_kwargs(kwargs : RedGreen::SyntaxNode?) : RedClassDef
      update(name, bases.to_a, keywords.to_a, starargs, kwargs, body.to_a, decorator_list.to_a)
    end

    def with_body(body : Array(RedGreen::SyntaxNode)) : RedClassDef
      update(name, bases.to_a, keywords.to_a, starargs, kwargs, body, decorator_list.to_a)
    end

    def with_decorator_list(decorator_list : Array(RedGreen::SyntaxNode)) : RedClassDef
      update(name, bases.to_a, keywords.to_a, starargs, kwargs, body.to_a, decorator_list)
    end
  end

  class GreenReturn < RedGreen::GreenNode
    getter value : RedGreen::GreenNode?

    def initialize(value : RedGreen::GreenNode?)
      @value = value
      flags = RedGreen::NodeFlags::None
      full_width = 0
      if value
        flags |= value.flags
        full_width += value.full_width
      end
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Return"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        value
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedReturn.new(self, parent, position)
    end
  end

  class RedReturn < RedGreen::SyntaxNode
    def initialize(green : GreenReturn, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def value : RedGreen::SyntaxNode?
      child_at(0)
    end

    def update(value : RedGreen::SyntaxNode?) : RedReturn
      return self if value == value
      green = GreenReturn.new(value.try(&.green))
      green.create_red(@parent, @position).as(RedReturn)
    end

    def with_value(value : RedGreen::SyntaxNode?) : RedReturn
      update(value)
    end
  end

  class GreenDelete < RedGreen::GreenNode
    getter targets : RedGreen::InternalSyntax::SyntaxList

    def initialize(targets : RedGreen::InternalSyntax::SyntaxList)
      @targets = targets
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= targets.flags
      full_width += targets.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Delete"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        targets
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedDelete.new(self, parent, position)
    end
  end

  class RedDelete < RedGreen::SyntaxNode
    def initialize(green : GreenDelete, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def targets : RedGreen::ChildSyntaxList
      list = @green.as(GreenDelete).targets
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def update(targets : Array(RedGreen::SyntaxNode)) : RedDelete
      return self if targets == targets.to_a
      green = GreenDelete.new(RedGreen::InternalSyntax::SyntaxList.new(targets.map(&.green)))
      green.create_red(@parent, @position).as(RedDelete)
    end

    def with_targets(targets : Array(RedGreen::SyntaxNode)) : RedDelete
      update(targets)
    end
  end

  class GreenAssign < RedGreen::GreenNode
    getter targets : RedGreen::InternalSyntax::SyntaxList
    getter value : RedGreen::GreenNode

    def initialize(targets : RedGreen::InternalSyntax::SyntaxList, value : RedGreen::GreenNode)
      @targets = targets
      @value = value
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= targets.flags
      full_width += targets.full_width
      flags |= value.flags
      full_width += value.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Assign"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        targets
      when 1
        value
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedAssign.new(self, parent, position)
    end
  end

  class RedAssign < RedGreen::SyntaxNode
    def initialize(green : GreenAssign, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def targets : RedGreen::ChildSyntaxList
      list = @green.as(GreenAssign).targets
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def value : RedGreen::SyntaxNode?
      child_at(1)
    end

    def update(targets : Array(RedGreen::SyntaxNode), value : RedGreen::SyntaxNode) : RedAssign
      return self if targets == targets.to_a && value == value
      green = GreenAssign.new(RedGreen::InternalSyntax::SyntaxList.new(targets.map(&.green)), value.green)
      green.create_red(@parent, @position).as(RedAssign)
    end

    def with_targets(targets : Array(RedGreen::SyntaxNode)) : RedAssign
      update(targets, value)
    end

    def with_value(value : RedGreen::SyntaxNode) : RedAssign
      update(targets.to_a, value)
    end
  end

  class GreenAugAssign < RedGreen::GreenNode
    getter target : RedGreen::GreenNode
    getter op : RedGreen::GreenNode
    getter value : RedGreen::GreenNode

    def initialize(target : RedGreen::GreenNode, op : RedGreen::GreenNode, value : RedGreen::GreenNode)
      @target = target
      @op = op
      @value = value
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= target.flags
      full_width += target.full_width
      flags |= op.flags
      full_width += op.full_width
      flags |= value.flags
      full_width += value.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 3)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "AugAssign"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        target
      when 1
        op
      when 2
        value
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedAugAssign.new(self, parent, position)
    end
  end

  class RedAugAssign < RedGreen::SyntaxNode
    def initialize(green : GreenAugAssign, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def target : RedGreen::SyntaxNode?
      child_at(0)
    end

    def op : RedGreen::SyntaxNode?
      child_at(1)
    end

    def value : RedGreen::SyntaxNode?
      child_at(2)
    end

    def update(target : RedGreen::SyntaxNode, op : RedGreen::SyntaxNode, value : RedGreen::SyntaxNode) : RedAugAssign
      return self if target == target && op == op && value == value
      green = GreenAugAssign.new(target.green, op.green, value.green)
      green.create_red(@parent, @position).as(RedAugAssign)
    end

    def with_target(target : RedGreen::SyntaxNode) : RedAugAssign
      update(target, op, value)
    end

    def with_op(op : RedGreen::SyntaxNode) : RedAugAssign
      update(target, op, value)
    end

    def with_value(value : RedGreen::SyntaxNode) : RedAugAssign
      update(target, op, value)
    end
  end

  class GreenFor < RedGreen::GreenNode
    getter target : RedGreen::GreenNode
    getter iter : RedGreen::GreenNode
    getter body : RedGreen::InternalSyntax::SyntaxList
    getter orelse : RedGreen::InternalSyntax::SyntaxList

    def initialize(target : RedGreen::GreenNode, iter : RedGreen::GreenNode, body : RedGreen::InternalSyntax::SyntaxList, orelse : RedGreen::InternalSyntax::SyntaxList)
      @target = target
      @iter = iter
      @body = body
      @orelse = orelse
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= target.flags
      full_width += target.full_width
      flags |= iter.flags
      full_width += iter.full_width
      flags |= body.flags
      full_width += body.full_width
      flags |= orelse.flags
      full_width += orelse.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 4)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "For"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        target
      when 1
        iter
      when 2
        body
      when 3
        orelse
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedFor.new(self, parent, position)
    end
  end

  class RedFor < RedGreen::SyntaxNode
    def initialize(green : GreenFor, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def target : RedGreen::SyntaxNode?
      child_at(0)
    end

    def iter : RedGreen::SyntaxNode?
      child_at(1)
    end

    def body : RedGreen::ChildSyntaxList
      list = @green.as(GreenFor).body
      RedGreen::SyntaxListNode.new(list, self, child_position(2)).child_nodes
    end

    def orelse : RedGreen::ChildSyntaxList
      list = @green.as(GreenFor).orelse
      RedGreen::SyntaxListNode.new(list, self, child_position(3)).child_nodes
    end

    def update(target : RedGreen::SyntaxNode, iter : RedGreen::SyntaxNode, body : Array(RedGreen::SyntaxNode), orelse : Array(RedGreen::SyntaxNode)) : RedFor
      return self if target == target && iter == iter && body == body.to_a && orelse == orelse.to_a
      green = GreenFor.new(target.green, iter.green, RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(orelse.map(&.green)))
      green.create_red(@parent, @position).as(RedFor)
    end

    def with_target(target : RedGreen::SyntaxNode) : RedFor
      update(target, iter, body.to_a, orelse.to_a)
    end

    def with_iter(iter : RedGreen::SyntaxNode) : RedFor
      update(target, iter, body.to_a, orelse.to_a)
    end

    def with_body(body : Array(RedGreen::SyntaxNode)) : RedFor
      update(target, iter, body, orelse.to_a)
    end

    def with_orelse(orelse : Array(RedGreen::SyntaxNode)) : RedFor
      update(target, iter, body.to_a, orelse)
    end
  end

  class GreenWhile < RedGreen::GreenNode
    getter test : RedGreen::GreenNode
    getter body : RedGreen::InternalSyntax::SyntaxList
    getter orelse : RedGreen::InternalSyntax::SyntaxList

    def initialize(test : RedGreen::GreenNode, body : RedGreen::InternalSyntax::SyntaxList, orelse : RedGreen::InternalSyntax::SyntaxList)
      @test = test
      @body = body
      @orelse = orelse
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= test.flags
      full_width += test.full_width
      flags |= body.flags
      full_width += body.full_width
      flags |= orelse.flags
      full_width += orelse.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 3)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "While"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        test
      when 1
        body
      when 2
        orelse
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedWhile.new(self, parent, position)
    end
  end

  class RedWhile < RedGreen::SyntaxNode
    def initialize(green : GreenWhile, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def test : RedGreen::SyntaxNode?
      child_at(0)
    end

    def body : RedGreen::ChildSyntaxList
      list = @green.as(GreenWhile).body
      RedGreen::SyntaxListNode.new(list, self, child_position(1)).child_nodes
    end

    def orelse : RedGreen::ChildSyntaxList
      list = @green.as(GreenWhile).orelse
      RedGreen::SyntaxListNode.new(list, self, child_position(2)).child_nodes
    end

    def update(test : RedGreen::SyntaxNode, body : Array(RedGreen::SyntaxNode), orelse : Array(RedGreen::SyntaxNode)) : RedWhile
      return self if test == test && body == body.to_a && orelse == orelse.to_a
      green = GreenWhile.new(test.green, RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(orelse.map(&.green)))
      green.create_red(@parent, @position).as(RedWhile)
    end

    def with_test(test : RedGreen::SyntaxNode) : RedWhile
      update(test, body.to_a, orelse.to_a)
    end

    def with_body(body : Array(RedGreen::SyntaxNode)) : RedWhile
      update(test, body, orelse.to_a)
    end

    def with_orelse(orelse : Array(RedGreen::SyntaxNode)) : RedWhile
      update(test, body.to_a, orelse)
    end
  end

  class GreenIf < RedGreen::GreenNode
    getter test : RedGreen::GreenNode
    getter body : RedGreen::InternalSyntax::SyntaxList
    getter orelse : RedGreen::InternalSyntax::SyntaxList

    def initialize(test : RedGreen::GreenNode, body : RedGreen::InternalSyntax::SyntaxList, orelse : RedGreen::InternalSyntax::SyntaxList)
      @test = test
      @body = body
      @orelse = orelse
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= test.flags
      full_width += test.full_width
      flags |= body.flags
      full_width += body.full_width
      flags |= orelse.flags
      full_width += orelse.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 3)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "If"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        test
      when 1
        body
      when 2
        orelse
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedIf.new(self, parent, position)
    end
  end

  class RedIf < RedGreen::SyntaxNode
    def initialize(green : GreenIf, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def test : RedGreen::SyntaxNode?
      child_at(0)
    end

    def body : RedGreen::ChildSyntaxList
      list = @green.as(GreenIf).body
      RedGreen::SyntaxListNode.new(list, self, child_position(1)).child_nodes
    end

    def orelse : RedGreen::ChildSyntaxList
      list = @green.as(GreenIf).orelse
      RedGreen::SyntaxListNode.new(list, self, child_position(2)).child_nodes
    end

    def update(test : RedGreen::SyntaxNode, body : Array(RedGreen::SyntaxNode), orelse : Array(RedGreen::SyntaxNode)) : RedIf
      return self if test == test && body == body.to_a && orelse == orelse.to_a
      green = GreenIf.new(test.green, RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(orelse.map(&.green)))
      green.create_red(@parent, @position).as(RedIf)
    end

    def with_test(test : RedGreen::SyntaxNode) : RedIf
      update(test, body.to_a, orelse.to_a)
    end

    def with_body(body : Array(RedGreen::SyntaxNode)) : RedIf
      update(test, body, orelse.to_a)
    end

    def with_orelse(orelse : Array(RedGreen::SyntaxNode)) : RedIf
      update(test, body.to_a, orelse)
    end
  end

  class GreenWith < RedGreen::GreenNode
    getter items : RedGreen::InternalSyntax::SyntaxList
    getter body : RedGreen::InternalSyntax::SyntaxList

    def initialize(items : RedGreen::InternalSyntax::SyntaxList, body : RedGreen::InternalSyntax::SyntaxList)
      @items = items
      @body = body
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= items.flags
      full_width += items.full_width
      flags |= body.flags
      full_width += body.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "With"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        items
      when 1
        body
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedWith.new(self, parent, position)
    end
  end

  class RedWith < RedGreen::SyntaxNode
    def initialize(green : GreenWith, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def items : RedGreen::ChildSyntaxList
      list = @green.as(GreenWith).items
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def body : RedGreen::ChildSyntaxList
      list = @green.as(GreenWith).body
      RedGreen::SyntaxListNode.new(list, self, child_position(1)).child_nodes
    end

    def update(items : Array(RedGreen::SyntaxNode), body : Array(RedGreen::SyntaxNode)) : RedWith
      return self if items == items.to_a && body == body.to_a
      green = GreenWith.new(RedGreen::InternalSyntax::SyntaxList.new(items.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)))
      green.create_red(@parent, @position).as(RedWith)
    end

    def with_items(items : Array(RedGreen::SyntaxNode)) : RedWith
      update(items, body.to_a)
    end

    def with_body(body : Array(RedGreen::SyntaxNode)) : RedWith
      update(items.to_a, body)
    end
  end

  class GreenRaise < RedGreen::GreenNode
    getter exc : RedGreen::GreenNode?
    getter cause : RedGreen::GreenNode?

    def initialize(exc : RedGreen::GreenNode?, cause : RedGreen::GreenNode?)
      @exc = exc
      @cause = cause
      flags = RedGreen::NodeFlags::None
      full_width = 0
      if exc
        flags |= exc.flags
        full_width += exc.full_width
      end
      if cause
        flags |= cause.flags
        full_width += cause.full_width
      end
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Raise"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        exc
      when 1
        cause
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedRaise.new(self, parent, position)
    end
  end

  class RedRaise < RedGreen::SyntaxNode
    def initialize(green : GreenRaise, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def exc : RedGreen::SyntaxNode?
      child_at(0)
    end

    def cause : RedGreen::SyntaxNode?
      child_at(1)
    end

    def update(exc : RedGreen::SyntaxNode?, cause : RedGreen::SyntaxNode?) : RedRaise
      return self if exc == exc && cause == cause
      green = GreenRaise.new(exc.try(&.green), cause.try(&.green))
      green.create_red(@parent, @position).as(RedRaise)
    end

    def with_exc(exc : RedGreen::SyntaxNode?) : RedRaise
      update(exc, cause)
    end

    def with_cause(cause : RedGreen::SyntaxNode?) : RedRaise
      update(exc, cause)
    end
  end

  class GreenTry < RedGreen::GreenNode
    getter body : RedGreen::InternalSyntax::SyntaxList
    getter handlers : RedGreen::InternalSyntax::SyntaxList
    getter orelse : RedGreen::InternalSyntax::SyntaxList
    getter finalbody : RedGreen::InternalSyntax::SyntaxList

    def initialize(body : RedGreen::InternalSyntax::SyntaxList, handlers : RedGreen::InternalSyntax::SyntaxList, orelse : RedGreen::InternalSyntax::SyntaxList, finalbody : RedGreen::InternalSyntax::SyntaxList)
      @body = body
      @handlers = handlers
      @orelse = orelse
      @finalbody = finalbody
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= body.flags
      full_width += body.full_width
      flags |= handlers.flags
      full_width += handlers.full_width
      flags |= orelse.flags
      full_width += orelse.full_width
      flags |= finalbody.flags
      full_width += finalbody.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 4)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Try"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        body
      when 1
        handlers
      when 2
        orelse
      when 3
        finalbody
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedTry.new(self, parent, position)
    end
  end

  class RedTry < RedGreen::SyntaxNode
    def initialize(green : GreenTry, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def body : RedGreen::ChildSyntaxList
      list = @green.as(GreenTry).body
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def handlers : RedGreen::ChildSyntaxList
      list = @green.as(GreenTry).handlers
      RedGreen::SyntaxListNode.new(list, self, child_position(1)).child_nodes
    end

    def orelse : RedGreen::ChildSyntaxList
      list = @green.as(GreenTry).orelse
      RedGreen::SyntaxListNode.new(list, self, child_position(2)).child_nodes
    end

    def finalbody : RedGreen::ChildSyntaxList
      list = @green.as(GreenTry).finalbody
      RedGreen::SyntaxListNode.new(list, self, child_position(3)).child_nodes
    end

    def update(body : Array(RedGreen::SyntaxNode), handlers : Array(RedGreen::SyntaxNode), orelse : Array(RedGreen::SyntaxNode), finalbody : Array(RedGreen::SyntaxNode)) : RedTry
      return self if body == body.to_a && handlers == handlers.to_a && orelse == orelse.to_a && finalbody == finalbody.to_a
      green = GreenTry.new(RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(handlers.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(orelse.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(finalbody.map(&.green)))
      green.create_red(@parent, @position).as(RedTry)
    end

    def with_body(body : Array(RedGreen::SyntaxNode)) : RedTry
      update(body, handlers.to_a, orelse.to_a, finalbody.to_a)
    end

    def with_handlers(handlers : Array(RedGreen::SyntaxNode)) : RedTry
      update(body.to_a, handlers, orelse.to_a, finalbody.to_a)
    end

    def with_orelse(orelse : Array(RedGreen::SyntaxNode)) : RedTry
      update(body.to_a, handlers.to_a, orelse, finalbody.to_a)
    end

    def with_finalbody(finalbody : Array(RedGreen::SyntaxNode)) : RedTry
      update(body.to_a, handlers.to_a, orelse.to_a, finalbody)
    end
  end

  class GreenAssert < RedGreen::GreenNode
    getter test : RedGreen::GreenNode
    getter msg : RedGreen::GreenNode?

    def initialize(test : RedGreen::GreenNode, msg : RedGreen::GreenNode?)
      @test = test
      @msg = msg
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= test.flags
      full_width += test.full_width
      if msg
        flags |= msg.flags
        full_width += msg.full_width
      end
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Assert"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        test
      when 1
        msg
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedAssert.new(self, parent, position)
    end
  end

  class RedAssert < RedGreen::SyntaxNode
    def initialize(green : GreenAssert, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def test : RedGreen::SyntaxNode?
      child_at(0)
    end

    def msg : RedGreen::SyntaxNode?
      child_at(1)
    end

    def update(test : RedGreen::SyntaxNode, msg : RedGreen::SyntaxNode?) : RedAssert
      return self if test == test && msg == msg
      green = GreenAssert.new(test.green, msg.try(&.green))
      green.create_red(@parent, @position).as(RedAssert)
    end

    def with_test(test : RedGreen::SyntaxNode) : RedAssert
      update(test, msg)
    end

    def with_msg(msg : RedGreen::SyntaxNode?) : RedAssert
      update(test, msg)
    end
  end

  class GreenImport < RedGreen::GreenNode
    getter names : RedGreen::InternalSyntax::SyntaxList

    def initialize(names : RedGreen::InternalSyntax::SyntaxList)
      @names = names
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= names.flags
      full_width += names.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Import"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        names
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedImport.new(self, parent, position)
    end
  end

  class RedImport < RedGreen::SyntaxNode
    def initialize(green : GreenImport, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def names : RedGreen::ChildSyntaxList
      list = @green.as(GreenImport).names
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def update(names : Array(RedGreen::SyntaxNode)) : RedImport
      return self if names == names.to_a
      green = GreenImport.new(RedGreen::InternalSyntax::SyntaxList.new(names.map(&.green)))
      green.create_red(@parent, @position).as(RedImport)
    end

    def with_names(names : Array(RedGreen::SyntaxNode)) : RedImport
      update(names)
    end
  end

  class GreenImportFrom < RedGreen::GreenNode
    getter module_ : String?
    getter names : RedGreen::InternalSyntax::SyntaxList
    getter level : Int32?

    def initialize(module_ : String?, names : RedGreen::InternalSyntax::SyntaxList, level : Int32?)
      @module_ = module_
      @names = names
      @level = level
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= names.flags
      full_width += names.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "ImportFrom"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        names
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedImportFrom.new(self, parent, position)
    end
  end

  class RedImportFrom < RedGreen::SyntaxNode
    def initialize(green : GreenImportFrom, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def module_ : String?
      @green.as(GreenImportFrom).module_
    end

    def names : RedGreen::ChildSyntaxList
      list = @green.as(GreenImportFrom).names
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def level : Int32?
      @green.as(GreenImportFrom).level
    end

    def update(module_ : String?, names : Array(RedGreen::SyntaxNode), level : Int32?) : RedImportFrom
      return self if module_ == module_ && names == names.to_a && level == level
      green = GreenImportFrom.new(module_, RedGreen::InternalSyntax::SyntaxList.new(names.map(&.green)), level)
      green.create_red(@parent, @position).as(RedImportFrom)
    end

    def with_module_(module_ : String?) : RedImportFrom
      update(module_, names.to_a, level)
    end

    def with_names(names : Array(RedGreen::SyntaxNode)) : RedImportFrom
      update(module_, names, level)
    end

    def with_level(level : Int32?) : RedImportFrom
      update(module_, names.to_a, level)
    end
  end

  class GreenGlobal < RedGreen::GreenNode
    getter names : Array(String)

    def initialize(names : Array(String))
      @names = names
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Global"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedGlobal.new(self, parent, position)
    end
  end

  class RedGlobal < RedGreen::SyntaxNode
    def initialize(green : GreenGlobal, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def names : Array(String)
      @green.as(GreenGlobal).names
    end

    def update(names : Array(String)) : RedGlobal
      return self if names == names
      green = GreenGlobal.new(names)
      green.create_red(@parent, @position).as(RedGlobal)
    end

    def with_names(names : Array(String)) : RedGlobal
      update(names)
    end
  end

  class GreenNonlocal < RedGreen::GreenNode
    getter names : Array(String)

    def initialize(names : Array(String))
      @names = names
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Nonlocal"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedNonlocal.new(self, parent, position)
    end
  end

  class RedNonlocal < RedGreen::SyntaxNode
    def initialize(green : GreenNonlocal, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def names : Array(String)
      @green.as(GreenNonlocal).names
    end

    def update(names : Array(String)) : RedNonlocal
      return self if names == names
      green = GreenNonlocal.new(names)
      green.create_red(@parent, @position).as(RedNonlocal)
    end

    def with_names(names : Array(String)) : RedNonlocal
      update(names)
    end
  end

  class GreenExpr < RedGreen::GreenNode
    getter value : RedGreen::GreenNode

    def initialize(value : RedGreen::GreenNode)
      @value = value
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= value.flags
      full_width += value.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Expr"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        value
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedExpr.new(self, parent, position)
    end
  end

  class RedExpr < RedGreen::SyntaxNode
    def initialize(green : GreenExpr, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def value : RedGreen::SyntaxNode?
      child_at(0)
    end

    def update(value : RedGreen::SyntaxNode) : RedExpr
      return self if value == value
      green = GreenExpr.new(value.green)
      green.create_red(@parent, @position).as(RedExpr)
    end

    def with_value(value : RedGreen::SyntaxNode) : RedExpr
      update(value)
    end
  end

  class GreenPass < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Pass"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedPass.new(self, parent, position)
    end
  end

  class RedPass < RedGreen::SyntaxNode
    def initialize(green : GreenPass, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedPass
      self
    end
  end

  class GreenBreak < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Break"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedBreak.new(self, parent, position)
    end
  end

  class RedBreak < RedGreen::SyntaxNode
    def initialize(green : GreenBreak, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedBreak
      self
    end
  end

  class GreenContinue < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Continue"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedContinue.new(self, parent, position)
    end
  end

  class RedContinue < RedGreen::SyntaxNode
    def initialize(green : GreenContinue, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedContinue
      self
    end
  end

  class GreenBoolOp < RedGreen::GreenNode
    getter op : RedGreen::GreenNode
    getter values : RedGreen::InternalSyntax::SyntaxList

    def initialize(op : RedGreen::GreenNode, values : RedGreen::InternalSyntax::SyntaxList)
      @op = op
      @values = values
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= op.flags
      full_width += op.full_width
      flags |= values.flags
      full_width += values.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "BoolOp"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        op
      when 1
        values
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedBoolOp.new(self, parent, position)
    end
  end

  class RedBoolOp < RedGreen::SyntaxNode
    def initialize(green : GreenBoolOp, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def op : RedGreen::SyntaxNode?
      child_at(0)
    end

    def values : RedGreen::ChildSyntaxList
      list = @green.as(GreenBoolOp).values
      RedGreen::SyntaxListNode.new(list, self, child_position(1)).child_nodes
    end

    def update(op : RedGreen::SyntaxNode, values : Array(RedGreen::SyntaxNode)) : RedBoolOp
      return self if op == op && values == values.to_a
      green = GreenBoolOp.new(op.green, RedGreen::InternalSyntax::SyntaxList.new(values.map(&.green)))
      green.create_red(@parent, @position).as(RedBoolOp)
    end

    def with_op(op : RedGreen::SyntaxNode) : RedBoolOp
      update(op, values.to_a)
    end

    def with_values(values : Array(RedGreen::SyntaxNode)) : RedBoolOp
      update(op, values)
    end
  end

  class GreenBinOp < RedGreen::GreenNode
    getter left : RedGreen::GreenNode
    getter op : RedGreen::GreenNode
    getter right : RedGreen::GreenNode

    def initialize(left : RedGreen::GreenNode, op : RedGreen::GreenNode, right : RedGreen::GreenNode)
      @left = left
      @op = op
      @right = right
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= left.flags
      full_width += left.full_width
      flags |= op.flags
      full_width += op.full_width
      flags |= right.flags
      full_width += right.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 3)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "BinOp"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        left
      when 1
        op
      when 2
        right
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedBinOp.new(self, parent, position)
    end
  end

  class RedBinOp < RedGreen::SyntaxNode
    def initialize(green : GreenBinOp, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def left : RedGreen::SyntaxNode?
      child_at(0)
    end

    def op : RedGreen::SyntaxNode?
      child_at(1)
    end

    def right : RedGreen::SyntaxNode?
      child_at(2)
    end

    def update(left : RedGreen::SyntaxNode, op : RedGreen::SyntaxNode, right : RedGreen::SyntaxNode) : RedBinOp
      return self if left == left && op == op && right == right
      green = GreenBinOp.new(left.green, op.green, right.green)
      green.create_red(@parent, @position).as(RedBinOp)
    end

    def with_left(left : RedGreen::SyntaxNode) : RedBinOp
      update(left, op, right)
    end

    def with_op(op : RedGreen::SyntaxNode) : RedBinOp
      update(left, op, right)
    end

    def with_right(right : RedGreen::SyntaxNode) : RedBinOp
      update(left, op, right)
    end
  end

  class GreenUnaryOp < RedGreen::GreenNode
    getter op : RedGreen::GreenNode
    getter operand : RedGreen::GreenNode

    def initialize(op : RedGreen::GreenNode, operand : RedGreen::GreenNode)
      @op = op
      @operand = operand
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= op.flags
      full_width += op.full_width
      flags |= operand.flags
      full_width += operand.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "UnaryOp"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        op
      when 1
        operand
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedUnaryOp.new(self, parent, position)
    end
  end

  class RedUnaryOp < RedGreen::SyntaxNode
    def initialize(green : GreenUnaryOp, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def op : RedGreen::SyntaxNode?
      child_at(0)
    end

    def operand : RedGreen::SyntaxNode?
      child_at(1)
    end

    def update(op : RedGreen::SyntaxNode, operand : RedGreen::SyntaxNode) : RedUnaryOp
      return self if op == op && operand == operand
      green = GreenUnaryOp.new(op.green, operand.green)
      green.create_red(@parent, @position).as(RedUnaryOp)
    end

    def with_op(op : RedGreen::SyntaxNode) : RedUnaryOp
      update(op, operand)
    end

    def with_operand(operand : RedGreen::SyntaxNode) : RedUnaryOp
      update(op, operand)
    end
  end

  class GreenLambda < RedGreen::GreenNode
    getter args : RedGreen::GreenNode
    getter body : RedGreen::GreenNode

    def initialize(args : RedGreen::GreenNode, body : RedGreen::GreenNode)
      @args = args
      @body = body
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= args.flags
      full_width += args.full_width
      flags |= body.flags
      full_width += body.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Lambda"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        args
      when 1
        body
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedLambda.new(self, parent, position)
    end
  end

  class RedLambda < RedGreen::SyntaxNode
    def initialize(green : GreenLambda, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def args : RedGreen::SyntaxNode?
      child_at(0)
    end

    def body : RedGreen::SyntaxNode?
      child_at(1)
    end

    def update(args : RedGreen::SyntaxNode, body : RedGreen::SyntaxNode) : RedLambda
      return self if args == args && body == body
      green = GreenLambda.new(args.green, body.green)
      green.create_red(@parent, @position).as(RedLambda)
    end

    def with_args(args : RedGreen::SyntaxNode) : RedLambda
      update(args, body)
    end

    def with_body(body : RedGreen::SyntaxNode) : RedLambda
      update(args, body)
    end
  end

  class GreenIfExp < RedGreen::GreenNode
    getter test : RedGreen::GreenNode
    getter body : RedGreen::GreenNode
    getter orelse : RedGreen::GreenNode

    def initialize(test : RedGreen::GreenNode, body : RedGreen::GreenNode, orelse : RedGreen::GreenNode)
      @test = test
      @body = body
      @orelse = orelse
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= test.flags
      full_width += test.full_width
      flags |= body.flags
      full_width += body.full_width
      flags |= orelse.flags
      full_width += orelse.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 3)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "IfExp"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        test
      when 1
        body
      when 2
        orelse
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedIfExp.new(self, parent, position)
    end
  end

  class RedIfExp < RedGreen::SyntaxNode
    def initialize(green : GreenIfExp, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def test : RedGreen::SyntaxNode?
      child_at(0)
    end

    def body : RedGreen::SyntaxNode?
      child_at(1)
    end

    def orelse : RedGreen::SyntaxNode?
      child_at(2)
    end

    def update(test : RedGreen::SyntaxNode, body : RedGreen::SyntaxNode, orelse : RedGreen::SyntaxNode) : RedIfExp
      return self if test == test && body == body && orelse == orelse
      green = GreenIfExp.new(test.green, body.green, orelse.green)
      green.create_red(@parent, @position).as(RedIfExp)
    end

    def with_test(test : RedGreen::SyntaxNode) : RedIfExp
      update(test, body, orelse)
    end

    def with_body(body : RedGreen::SyntaxNode) : RedIfExp
      update(test, body, orelse)
    end

    def with_orelse(orelse : RedGreen::SyntaxNode) : RedIfExp
      update(test, body, orelse)
    end
  end

  class GreenDict < RedGreen::GreenNode
    getter keys : RedGreen::InternalSyntax::SyntaxList
    getter values : RedGreen::InternalSyntax::SyntaxList

    def initialize(keys : RedGreen::InternalSyntax::SyntaxList, values : RedGreen::InternalSyntax::SyntaxList)
      @keys = keys
      @values = values
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= keys.flags
      full_width += keys.full_width
      flags |= values.flags
      full_width += values.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Dict"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        keys
      when 1
        values
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedDict.new(self, parent, position)
    end
  end

  class RedDict < RedGreen::SyntaxNode
    def initialize(green : GreenDict, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def keys : RedGreen::ChildSyntaxList
      list = @green.as(GreenDict).keys
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def values : RedGreen::ChildSyntaxList
      list = @green.as(GreenDict).values
      RedGreen::SyntaxListNode.new(list, self, child_position(1)).child_nodes
    end

    def update(keys : Array(RedGreen::SyntaxNode), values : Array(RedGreen::SyntaxNode)) : RedDict
      return self if keys == keys.to_a && values == values.to_a
      green = GreenDict.new(RedGreen::InternalSyntax::SyntaxList.new(keys.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(values.map(&.green)))
      green.create_red(@parent, @position).as(RedDict)
    end

    def with_keys(keys : Array(RedGreen::SyntaxNode)) : RedDict
      update(keys, values.to_a)
    end

    def with_values(values : Array(RedGreen::SyntaxNode)) : RedDict
      update(keys.to_a, values)
    end
  end

  class GreenSet < RedGreen::GreenNode
    getter elts : RedGreen::InternalSyntax::SyntaxList

    def initialize(elts : RedGreen::InternalSyntax::SyntaxList)
      @elts = elts
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= elts.flags
      full_width += elts.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Set"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        elts
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedSet.new(self, parent, position)
    end
  end

  class RedSet < RedGreen::SyntaxNode
    def initialize(green : GreenSet, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def elts : RedGreen::ChildSyntaxList
      list = @green.as(GreenSet).elts
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def update(elts : Array(RedGreen::SyntaxNode)) : RedSet
      return self if elts == elts.to_a
      green = GreenSet.new(RedGreen::InternalSyntax::SyntaxList.new(elts.map(&.green)))
      green.create_red(@parent, @position).as(RedSet)
    end

    def with_elts(elts : Array(RedGreen::SyntaxNode)) : RedSet
      update(elts)
    end
  end

  class GreenListComp < RedGreen::GreenNode
    getter elt : RedGreen::GreenNode
    getter generators : RedGreen::InternalSyntax::SyntaxList

    def initialize(elt : RedGreen::GreenNode, generators : RedGreen::InternalSyntax::SyntaxList)
      @elt = elt
      @generators = generators
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= elt.flags
      full_width += elt.full_width
      flags |= generators.flags
      full_width += generators.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "ListComp"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        elt
      when 1
        generators
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedListComp.new(self, parent, position)
    end
  end

  class RedListComp < RedGreen::SyntaxNode
    def initialize(green : GreenListComp, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def elt : RedGreen::SyntaxNode?
      child_at(0)
    end

    def generators : RedGreen::ChildSyntaxList
      list = @green.as(GreenListComp).generators
      RedGreen::SyntaxListNode.new(list, self, child_position(1)).child_nodes
    end

    def update(elt : RedGreen::SyntaxNode, generators : Array(RedGreen::SyntaxNode)) : RedListComp
      return self if elt == elt && generators == generators.to_a
      green = GreenListComp.new(elt.green, RedGreen::InternalSyntax::SyntaxList.new(generators.map(&.green)))
      green.create_red(@parent, @position).as(RedListComp)
    end

    def with_elt(elt : RedGreen::SyntaxNode) : RedListComp
      update(elt, generators.to_a)
    end

    def with_generators(generators : Array(RedGreen::SyntaxNode)) : RedListComp
      update(elt, generators)
    end
  end

  class GreenSetComp < RedGreen::GreenNode
    getter elt : RedGreen::GreenNode
    getter generators : RedGreen::InternalSyntax::SyntaxList

    def initialize(elt : RedGreen::GreenNode, generators : RedGreen::InternalSyntax::SyntaxList)
      @elt = elt
      @generators = generators
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= elt.flags
      full_width += elt.full_width
      flags |= generators.flags
      full_width += generators.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "SetComp"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        elt
      when 1
        generators
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedSetComp.new(self, parent, position)
    end
  end

  class RedSetComp < RedGreen::SyntaxNode
    def initialize(green : GreenSetComp, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def elt : RedGreen::SyntaxNode?
      child_at(0)
    end

    def generators : RedGreen::ChildSyntaxList
      list = @green.as(GreenSetComp).generators
      RedGreen::SyntaxListNode.new(list, self, child_position(1)).child_nodes
    end

    def update(elt : RedGreen::SyntaxNode, generators : Array(RedGreen::SyntaxNode)) : RedSetComp
      return self if elt == elt && generators == generators.to_a
      green = GreenSetComp.new(elt.green, RedGreen::InternalSyntax::SyntaxList.new(generators.map(&.green)))
      green.create_red(@parent, @position).as(RedSetComp)
    end

    def with_elt(elt : RedGreen::SyntaxNode) : RedSetComp
      update(elt, generators.to_a)
    end

    def with_generators(generators : Array(RedGreen::SyntaxNode)) : RedSetComp
      update(elt, generators)
    end
  end

  class GreenDictComp < RedGreen::GreenNode
    getter key : RedGreen::GreenNode
    getter value : RedGreen::GreenNode
    getter generators : RedGreen::InternalSyntax::SyntaxList

    def initialize(key : RedGreen::GreenNode, value : RedGreen::GreenNode, generators : RedGreen::InternalSyntax::SyntaxList)
      @key = key
      @value = value
      @generators = generators
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= key.flags
      full_width += key.full_width
      flags |= value.flags
      full_width += value.full_width
      flags |= generators.flags
      full_width += generators.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 3)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "DictComp"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        key
      when 1
        value
      when 2
        generators
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedDictComp.new(self, parent, position)
    end
  end

  class RedDictComp < RedGreen::SyntaxNode
    def initialize(green : GreenDictComp, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def key : RedGreen::SyntaxNode?
      child_at(0)
    end

    def value : RedGreen::SyntaxNode?
      child_at(1)
    end

    def generators : RedGreen::ChildSyntaxList
      list = @green.as(GreenDictComp).generators
      RedGreen::SyntaxListNode.new(list, self, child_position(2)).child_nodes
    end

    def update(key : RedGreen::SyntaxNode, value : RedGreen::SyntaxNode, generators : Array(RedGreen::SyntaxNode)) : RedDictComp
      return self if key == key && value == value && generators == generators.to_a
      green = GreenDictComp.new(key.green, value.green, RedGreen::InternalSyntax::SyntaxList.new(generators.map(&.green)))
      green.create_red(@parent, @position).as(RedDictComp)
    end

    def with_key(key : RedGreen::SyntaxNode) : RedDictComp
      update(key, value, generators.to_a)
    end

    def with_value(value : RedGreen::SyntaxNode) : RedDictComp
      update(key, value, generators.to_a)
    end

    def with_generators(generators : Array(RedGreen::SyntaxNode)) : RedDictComp
      update(key, value, generators)
    end
  end

  class GreenGeneratorExp < RedGreen::GreenNode
    getter elt : RedGreen::GreenNode
    getter generators : RedGreen::InternalSyntax::SyntaxList

    def initialize(elt : RedGreen::GreenNode, generators : RedGreen::InternalSyntax::SyntaxList)
      @elt = elt
      @generators = generators
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= elt.flags
      full_width += elt.full_width
      flags |= generators.flags
      full_width += generators.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "GeneratorExp"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        elt
      when 1
        generators
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedGeneratorExp.new(self, parent, position)
    end
  end

  class RedGeneratorExp < RedGreen::SyntaxNode
    def initialize(green : GreenGeneratorExp, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def elt : RedGreen::SyntaxNode?
      child_at(0)
    end

    def generators : RedGreen::ChildSyntaxList
      list = @green.as(GreenGeneratorExp).generators
      RedGreen::SyntaxListNode.new(list, self, child_position(1)).child_nodes
    end

    def update(elt : RedGreen::SyntaxNode, generators : Array(RedGreen::SyntaxNode)) : RedGeneratorExp
      return self if elt == elt && generators == generators.to_a
      green = GreenGeneratorExp.new(elt.green, RedGreen::InternalSyntax::SyntaxList.new(generators.map(&.green)))
      green.create_red(@parent, @position).as(RedGeneratorExp)
    end

    def with_elt(elt : RedGreen::SyntaxNode) : RedGeneratorExp
      update(elt, generators.to_a)
    end

    def with_generators(generators : Array(RedGreen::SyntaxNode)) : RedGeneratorExp
      update(elt, generators)
    end
  end

  class GreenYield < RedGreen::GreenNode
    getter value : RedGreen::GreenNode?

    def initialize(value : RedGreen::GreenNode?)
      @value = value
      flags = RedGreen::NodeFlags::None
      full_width = 0
      if value
        flags |= value.flags
        full_width += value.full_width
      end
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Yield"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        value
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedYield.new(self, parent, position)
    end
  end

  class RedYield < RedGreen::SyntaxNode
    def initialize(green : GreenYield, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def value : RedGreen::SyntaxNode?
      child_at(0)
    end

    def update(value : RedGreen::SyntaxNode?) : RedYield
      return self if value == value
      green = GreenYield.new(value.try(&.green))
      green.create_red(@parent, @position).as(RedYield)
    end

    def with_value(value : RedGreen::SyntaxNode?) : RedYield
      update(value)
    end
  end

  class GreenYieldFrom < RedGreen::GreenNode
    getter value : RedGreen::GreenNode

    def initialize(value : RedGreen::GreenNode)
      @value = value
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= value.flags
      full_width += value.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "YieldFrom"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        value
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedYieldFrom.new(self, parent, position)
    end
  end

  class RedYieldFrom < RedGreen::SyntaxNode
    def initialize(green : GreenYieldFrom, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def value : RedGreen::SyntaxNode?
      child_at(0)
    end

    def update(value : RedGreen::SyntaxNode) : RedYieldFrom
      return self if value == value
      green = GreenYieldFrom.new(value.green)
      green.create_red(@parent, @position).as(RedYieldFrom)
    end

    def with_value(value : RedGreen::SyntaxNode) : RedYieldFrom
      update(value)
    end
  end

  class GreenCompare < RedGreen::GreenNode
    getter left : RedGreen::GreenNode
    getter ops : RedGreen::InternalSyntax::SyntaxList
    getter comparators : RedGreen::InternalSyntax::SyntaxList

    def initialize(left : RedGreen::GreenNode, ops : RedGreen::InternalSyntax::SyntaxList, comparators : RedGreen::InternalSyntax::SyntaxList)
      @left = left
      @ops = ops
      @comparators = comparators
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= left.flags
      full_width += left.full_width
      flags |= ops.flags
      full_width += ops.full_width
      flags |= comparators.flags
      full_width += comparators.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 3)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Compare"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        left
      when 1
        ops
      when 2
        comparators
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedCompare.new(self, parent, position)
    end
  end

  class RedCompare < RedGreen::SyntaxNode
    def initialize(green : GreenCompare, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def left : RedGreen::SyntaxNode?
      child_at(0)
    end

    def ops : RedGreen::ChildSyntaxList
      list = @green.as(GreenCompare).ops
      RedGreen::SyntaxListNode.new(list, self, child_position(1)).child_nodes
    end

    def comparators : RedGreen::ChildSyntaxList
      list = @green.as(GreenCompare).comparators
      RedGreen::SyntaxListNode.new(list, self, child_position(2)).child_nodes
    end

    def update(left : RedGreen::SyntaxNode, ops : Array(RedGreen::SyntaxNode), comparators : Array(RedGreen::SyntaxNode)) : RedCompare
      return self if left == left && ops == ops.to_a && comparators == comparators.to_a
      green = GreenCompare.new(left.green, RedGreen::InternalSyntax::SyntaxList.new(ops.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(comparators.map(&.green)))
      green.create_red(@parent, @position).as(RedCompare)
    end

    def with_left(left : RedGreen::SyntaxNode) : RedCompare
      update(left, ops.to_a, comparators.to_a)
    end

    def with_ops(ops : Array(RedGreen::SyntaxNode)) : RedCompare
      update(left, ops, comparators.to_a)
    end

    def with_comparators(comparators : Array(RedGreen::SyntaxNode)) : RedCompare
      update(left, ops.to_a, comparators)
    end
  end

  class GreenCall < RedGreen::GreenNode
    getter func : RedGreen::GreenNode
    getter args : RedGreen::InternalSyntax::SyntaxList
    getter keywords : RedGreen::InternalSyntax::SyntaxList
    getter starargs : RedGreen::GreenNode?
    getter kwargs : RedGreen::GreenNode?

    def initialize(func : RedGreen::GreenNode, args : RedGreen::InternalSyntax::SyntaxList, keywords : RedGreen::InternalSyntax::SyntaxList, starargs : RedGreen::GreenNode?, kwargs : RedGreen::GreenNode?)
      @func = func
      @args = args
      @keywords = keywords
      @starargs = starargs
      @kwargs = kwargs
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= func.flags
      full_width += func.full_width
      flags |= args.flags
      full_width += args.full_width
      flags |= keywords.flags
      full_width += keywords.full_width
      if starargs
        flags |= starargs.flags
        full_width += starargs.full_width
      end
      if kwargs
        flags |= kwargs.flags
        full_width += kwargs.full_width
      end
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 5)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Call"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        func
      when 1
        args
      when 2
        keywords
      when 3
        starargs
      when 4
        kwargs
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedCall.new(self, parent, position)
    end
  end

  class RedCall < RedGreen::SyntaxNode
    def initialize(green : GreenCall, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def func : RedGreen::SyntaxNode?
      child_at(0)
    end

    def args : RedGreen::ChildSyntaxList
      list = @green.as(GreenCall).args
      RedGreen::SyntaxListNode.new(list, self, child_position(1)).child_nodes
    end

    def keywords : RedGreen::ChildSyntaxList
      list = @green.as(GreenCall).keywords
      RedGreen::SyntaxListNode.new(list, self, child_position(2)).child_nodes
    end

    def starargs : RedGreen::SyntaxNode?
      child_at(3)
    end

    def kwargs : RedGreen::SyntaxNode?
      child_at(4)
    end

    def update(func : RedGreen::SyntaxNode, args : Array(RedGreen::SyntaxNode), keywords : Array(RedGreen::SyntaxNode), starargs : RedGreen::SyntaxNode?, kwargs : RedGreen::SyntaxNode?) : RedCall
      return self if func == func && args == args.to_a && keywords == keywords.to_a && starargs == starargs && kwargs == kwargs
      green = GreenCall.new(func.green, RedGreen::InternalSyntax::SyntaxList.new(args.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(keywords.map(&.green)), starargs.try(&.green), kwargs.try(&.green))
      green.create_red(@parent, @position).as(RedCall)
    end

    def with_func(func : RedGreen::SyntaxNode) : RedCall
      update(func, args.to_a, keywords.to_a, starargs, kwargs)
    end

    def with_args(args : Array(RedGreen::SyntaxNode)) : RedCall
      update(func, args, keywords.to_a, starargs, kwargs)
    end

    def with_keywords(keywords : Array(RedGreen::SyntaxNode)) : RedCall
      update(func, args.to_a, keywords, starargs, kwargs)
    end

    def with_starargs(starargs : RedGreen::SyntaxNode?) : RedCall
      update(func, args.to_a, keywords.to_a, starargs, kwargs)
    end

    def with_kwargs(kwargs : RedGreen::SyntaxNode?) : RedCall
      update(func, args.to_a, keywords.to_a, starargs, kwargs)
    end
  end

  class GreenNum < RedGreen::GreenNode
    getter n : String

    def initialize(n : String)
      @n = n
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Num"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedNum.new(self, parent, position)
    end
  end

  class RedNum < RedGreen::SyntaxNode
    def initialize(green : GreenNum, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def n : String
      @green.as(GreenNum).n
    end

    def update(n : String) : RedNum
      return self if n == n
      green = GreenNum.new(n)
      green.create_red(@parent, @position).as(RedNum)
    end

    def with_n(n : String) : RedNum
      update(n)
    end
  end

  class GreenStr < RedGreen::GreenNode
    getter s : String

    def initialize(s : String)
      @s = s
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Str"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedStr.new(self, parent, position)
    end
  end

  class RedStr < RedGreen::SyntaxNode
    def initialize(green : GreenStr, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def s : String
      @green.as(GreenStr).s
    end

    def update(s : String) : RedStr
      return self if s == s
      green = GreenStr.new(s)
      green.create_red(@parent, @position).as(RedStr)
    end

    def with_s(s : String) : RedStr
      update(s)
    end
  end

  class GreenBytes < RedGreen::GreenNode
    getter s : String

    def initialize(s : String)
      @s = s
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Bytes"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedBytes.new(self, parent, position)
    end
  end

  class RedBytes < RedGreen::SyntaxNode
    def initialize(green : GreenBytes, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def s : String
      @green.as(GreenBytes).s
    end

    def update(s : String) : RedBytes
      return self if s == s
      green = GreenBytes.new(s)
      green.create_red(@parent, @position).as(RedBytes)
    end

    def with_s(s : String) : RedBytes
      update(s)
    end
  end

  class GreenNameConstant < RedGreen::GreenNode
    getter? value : Bool

    def initialize(value : Bool)
      @value = value
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "NameConstant"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedNameConstant.new(self, parent, position)
    end
  end

  class RedNameConstant < RedGreen::SyntaxNode
    def initialize(green : GreenNameConstant, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def value? : Bool
      @green.as(GreenNameConstant).value
    end

    def update(value : Bool) : RedNameConstant
      return self if value == value
      green = GreenNameConstant.new(value)
      green.create_red(@parent, @position).as(RedNameConstant)
    end

    def with_value(value : Bool) : RedNameConstant
      update(value)
    end
  end

  class GreenEllipsis < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Ellipsis"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedEllipsis.new(self, parent, position)
    end
  end

  class RedEllipsis < RedGreen::SyntaxNode
    def initialize(green : GreenEllipsis, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedEllipsis
      self
    end
  end

  class GreenAttribute < RedGreen::GreenNode
    getter value : RedGreen::GreenNode
    getter attr : String
    getter ctx : RedGreen::GreenNode

    def initialize(value : RedGreen::GreenNode, attr : String, ctx : RedGreen::GreenNode)
      @value = value
      @attr = attr
      @ctx = ctx
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= value.flags
      full_width += value.full_width
      flags |= ctx.flags
      full_width += ctx.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Attribute"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        value
      when 1
        ctx
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedAttribute.new(self, parent, position)
    end
  end

  class RedAttribute < RedGreen::SyntaxNode
    def initialize(green : GreenAttribute, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def value : RedGreen::SyntaxNode?
      child_at(0)
    end

    def attr : String
      @green.as(GreenAttribute).attr
    end

    def ctx : RedGreen::SyntaxNode?
      child_at(1)
    end

    def update(value : RedGreen::SyntaxNode, attr : String, ctx : RedGreen::SyntaxNode) : RedAttribute
      return self if value == value && attr == attr && ctx == ctx
      green = GreenAttribute.new(value.green, attr, ctx.green)
      green.create_red(@parent, @position).as(RedAttribute)
    end

    def with_value(value : RedGreen::SyntaxNode) : RedAttribute
      update(value, attr, ctx)
    end

    def with_attr(attr : String) : RedAttribute
      update(value, attr, ctx)
    end

    def with_ctx(ctx : RedGreen::SyntaxNode) : RedAttribute
      update(value, attr, ctx)
    end
  end

  class GreenSubscript < RedGreen::GreenNode
    getter value : RedGreen::GreenNode
    getter slice : RedGreen::GreenNode
    getter ctx : RedGreen::GreenNode

    def initialize(value : RedGreen::GreenNode, slice : RedGreen::GreenNode, ctx : RedGreen::GreenNode)
      @value = value
      @slice = slice
      @ctx = ctx
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= value.flags
      full_width += value.full_width
      flags |= slice.flags
      full_width += slice.full_width
      flags |= ctx.flags
      full_width += ctx.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 3)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Subscript"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        value
      when 1
        slice
      when 2
        ctx
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedSubscript.new(self, parent, position)
    end
  end

  class RedSubscript < RedGreen::SyntaxNode
    def initialize(green : GreenSubscript, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def value : RedGreen::SyntaxNode?
      child_at(0)
    end

    def slice : RedGreen::SyntaxNode?
      child_at(1)
    end

    def ctx : RedGreen::SyntaxNode?
      child_at(2)
    end

    def update(value : RedGreen::SyntaxNode, slice : RedGreen::SyntaxNode, ctx : RedGreen::SyntaxNode) : RedSubscript
      return self if value == value && slice == slice && ctx == ctx
      green = GreenSubscript.new(value.green, slice.green, ctx.green)
      green.create_red(@parent, @position).as(RedSubscript)
    end

    def with_value(value : RedGreen::SyntaxNode) : RedSubscript
      update(value, slice, ctx)
    end

    def with_slice(slice : RedGreen::SyntaxNode) : RedSubscript
      update(value, slice, ctx)
    end

    def with_ctx(ctx : RedGreen::SyntaxNode) : RedSubscript
      update(value, slice, ctx)
    end
  end

  class GreenStarred < RedGreen::GreenNode
    getter value : RedGreen::GreenNode
    getter ctx : RedGreen::GreenNode

    def initialize(value : RedGreen::GreenNode, ctx : RedGreen::GreenNode)
      @value = value
      @ctx = ctx
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= value.flags
      full_width += value.full_width
      flags |= ctx.flags
      full_width += ctx.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Starred"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        value
      when 1
        ctx
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedStarred.new(self, parent, position)
    end
  end

  class RedStarred < RedGreen::SyntaxNode
    def initialize(green : GreenStarred, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def value : RedGreen::SyntaxNode?
      child_at(0)
    end

    def ctx : RedGreen::SyntaxNode?
      child_at(1)
    end

    def update(value : RedGreen::SyntaxNode, ctx : RedGreen::SyntaxNode) : RedStarred
      return self if value == value && ctx == ctx
      green = GreenStarred.new(value.green, ctx.green)
      green.create_red(@parent, @position).as(RedStarred)
    end

    def with_value(value : RedGreen::SyntaxNode) : RedStarred
      update(value, ctx)
    end

    def with_ctx(ctx : RedGreen::SyntaxNode) : RedStarred
      update(value, ctx)
    end
  end

  class GreenName < RedGreen::GreenNode
    getter id : String
    getter ctx : RedGreen::GreenNode

    def initialize(id : String, ctx : RedGreen::GreenNode)
      @id = id
      @ctx = ctx
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= ctx.flags
      full_width += ctx.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Name"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        ctx
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedName.new(self, parent, position)
    end
  end

  class RedName < RedGreen::SyntaxNode
    def initialize(green : GreenName, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def id : String
      @green.as(GreenName).id
    end

    def ctx : RedGreen::SyntaxNode?
      child_at(0)
    end

    def update(id : String, ctx : RedGreen::SyntaxNode) : RedName
      return self if id == id && ctx == ctx
      green = GreenName.new(id, ctx.green)
      green.create_red(@parent, @position).as(RedName)
    end

    def with_id(id : String) : RedName
      update(id, ctx)
    end

    def with_ctx(ctx : RedGreen::SyntaxNode) : RedName
      update(id, ctx)
    end
  end

  class GreenList < RedGreen::GreenNode
    getter elts : RedGreen::InternalSyntax::SyntaxList
    getter ctx : RedGreen::GreenNode

    def initialize(elts : RedGreen::InternalSyntax::SyntaxList, ctx : RedGreen::GreenNode)
      @elts = elts
      @ctx = ctx
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= elts.flags
      full_width += elts.full_width
      flags |= ctx.flags
      full_width += ctx.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "List"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        elts
      when 1
        ctx
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedList.new(self, parent, position)
    end
  end

  class RedList < RedGreen::SyntaxNode
    def initialize(green : GreenList, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def elts : RedGreen::ChildSyntaxList
      list = @green.as(GreenList).elts
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def ctx : RedGreen::SyntaxNode?
      child_at(1)
    end

    def update(elts : Array(RedGreen::SyntaxNode), ctx : RedGreen::SyntaxNode) : RedList
      return self if elts == elts.to_a && ctx == ctx
      green = GreenList.new(RedGreen::InternalSyntax::SyntaxList.new(elts.map(&.green)), ctx.green)
      green.create_red(@parent, @position).as(RedList)
    end

    def with_elts(elts : Array(RedGreen::SyntaxNode)) : RedList
      update(elts, ctx)
    end

    def with_ctx(ctx : RedGreen::SyntaxNode) : RedList
      update(elts.to_a, ctx)
    end
  end

  class GreenTuple < RedGreen::GreenNode
    getter elts : RedGreen::InternalSyntax::SyntaxList
    getter ctx : RedGreen::GreenNode

    def initialize(elts : RedGreen::InternalSyntax::SyntaxList, ctx : RedGreen::GreenNode)
      @elts = elts
      @ctx = ctx
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= elts.flags
      full_width += elts.full_width
      flags |= ctx.flags
      full_width += ctx.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Tuple"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        elts
      when 1
        ctx
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedTuple.new(self, parent, position)
    end
  end

  class RedTuple < RedGreen::SyntaxNode
    def initialize(green : GreenTuple, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def elts : RedGreen::ChildSyntaxList
      list = @green.as(GreenTuple).elts
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def ctx : RedGreen::SyntaxNode?
      child_at(1)
    end

    def update(elts : Array(RedGreen::SyntaxNode), ctx : RedGreen::SyntaxNode) : RedTuple
      return self if elts == elts.to_a && ctx == ctx
      green = GreenTuple.new(RedGreen::InternalSyntax::SyntaxList.new(elts.map(&.green)), ctx.green)
      green.create_red(@parent, @position).as(RedTuple)
    end

    def with_elts(elts : Array(RedGreen::SyntaxNode)) : RedTuple
      update(elts, ctx)
    end

    def with_ctx(ctx : RedGreen::SyntaxNode) : RedTuple
      update(elts.to_a, ctx)
    end
  end

  class GreenLoad < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Load"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedLoad.new(self, parent, position)
    end
  end

  class RedLoad < RedGreen::SyntaxNode
    def initialize(green : GreenLoad, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedLoad
      self
    end
  end

  class GreenStore < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Store"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedStore.new(self, parent, position)
    end
  end

  class RedStore < RedGreen::SyntaxNode
    def initialize(green : GreenStore, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedStore
      self
    end
  end

  class GreenDel < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Del"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedDel.new(self, parent, position)
    end
  end

  class RedDel < RedGreen::SyntaxNode
    def initialize(green : GreenDel, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedDel
      self
    end
  end

  class GreenAugLoad < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "AugLoad"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedAugLoad.new(self, parent, position)
    end
  end

  class RedAugLoad < RedGreen::SyntaxNode
    def initialize(green : GreenAugLoad, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedAugLoad
      self
    end
  end

  class GreenAugStore < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "AugStore"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedAugStore.new(self, parent, position)
    end
  end

  class RedAugStore < RedGreen::SyntaxNode
    def initialize(green : GreenAugStore, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedAugStore
      self
    end
  end

  class GreenParam < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Param"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedParam.new(self, parent, position)
    end
  end

  class RedParam < RedGreen::SyntaxNode
    def initialize(green : GreenParam, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedParam
      self
    end
  end

  class GreenSlice < RedGreen::GreenNode
    getter lower : RedGreen::GreenNode?
    getter upper : RedGreen::GreenNode?
    getter step : RedGreen::GreenNode?

    def initialize(lower : RedGreen::GreenNode?, upper : RedGreen::GreenNode?, step : RedGreen::GreenNode?)
      @lower = lower
      @upper = upper
      @step = step
      flags = RedGreen::NodeFlags::None
      full_width = 0
      if lower
        flags |= lower.flags
        full_width += lower.full_width
      end
      if upper
        flags |= upper.flags
        full_width += upper.full_width
      end
      if step
        flags |= step.flags
        full_width += step.full_width
      end
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 3)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Slice"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        lower
      when 1
        upper
      when 2
        step
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedSlice.new(self, parent, position)
    end
  end

  class RedSlice < RedGreen::SyntaxNode
    def initialize(green : GreenSlice, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def lower : RedGreen::SyntaxNode?
      child_at(0)
    end

    def upper : RedGreen::SyntaxNode?
      child_at(1)
    end

    def step : RedGreen::SyntaxNode?
      child_at(2)
    end

    def update(lower : RedGreen::SyntaxNode?, upper : RedGreen::SyntaxNode?, step : RedGreen::SyntaxNode?) : RedSlice
      return self if lower == lower && upper == upper && step == step
      green = GreenSlice.new(lower.try(&.green), upper.try(&.green), step.try(&.green))
      green.create_red(@parent, @position).as(RedSlice)
    end

    def with_lower(lower : RedGreen::SyntaxNode?) : RedSlice
      update(lower, upper, step)
    end

    def with_upper(upper : RedGreen::SyntaxNode?) : RedSlice
      update(lower, upper, step)
    end

    def with_step(step : RedGreen::SyntaxNode?) : RedSlice
      update(lower, upper, step)
    end
  end

  class GreenExtSlice < RedGreen::GreenNode
    getter dims : RedGreen::InternalSyntax::SyntaxList

    def initialize(dims : RedGreen::InternalSyntax::SyntaxList)
      @dims = dims
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= dims.flags
      full_width += dims.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "ExtSlice"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        dims
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedExtSlice.new(self, parent, position)
    end
  end

  class RedExtSlice < RedGreen::SyntaxNode
    def initialize(green : GreenExtSlice, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def dims : RedGreen::ChildSyntaxList
      list = @green.as(GreenExtSlice).dims
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def update(dims : Array(RedGreen::SyntaxNode)) : RedExtSlice
      return self if dims == dims.to_a
      green = GreenExtSlice.new(RedGreen::InternalSyntax::SyntaxList.new(dims.map(&.green)))
      green.create_red(@parent, @position).as(RedExtSlice)
    end

    def with_dims(dims : Array(RedGreen::SyntaxNode)) : RedExtSlice
      update(dims)
    end
  end

  class GreenIndex < RedGreen::GreenNode
    getter value : RedGreen::GreenNode

    def initialize(value : RedGreen::GreenNode)
      @value = value
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= value.flags
      full_width += value.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Index"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        value
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedIndex.new(self, parent, position)
    end
  end

  class RedIndex < RedGreen::SyntaxNode
    def initialize(green : GreenIndex, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def value : RedGreen::SyntaxNode?
      child_at(0)
    end

    def update(value : RedGreen::SyntaxNode) : RedIndex
      return self if value == value
      green = GreenIndex.new(value.green)
      green.create_red(@parent, @position).as(RedIndex)
    end

    def with_value(value : RedGreen::SyntaxNode) : RedIndex
      update(value)
    end
  end

  class GreenAnd < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "And"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedAnd.new(self, parent, position)
    end
  end

  class RedAnd < RedGreen::SyntaxNode
    def initialize(green : GreenAnd, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedAnd
      self
    end
  end

  class GreenOr < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Or"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedOr.new(self, parent, position)
    end
  end

  class RedOr < RedGreen::SyntaxNode
    def initialize(green : GreenOr, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedOr
      self
    end
  end

  class GreenAdd < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Add"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedAdd.new(self, parent, position)
    end
  end

  class RedAdd < RedGreen::SyntaxNode
    def initialize(green : GreenAdd, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedAdd
      self
    end
  end

  class GreenSub < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Sub"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedSub.new(self, parent, position)
    end
  end

  class RedSub < RedGreen::SyntaxNode
    def initialize(green : GreenSub, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedSub
      self
    end
  end

  class GreenMult < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Mult"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedMult.new(self, parent, position)
    end
  end

  class RedMult < RedGreen::SyntaxNode
    def initialize(green : GreenMult, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedMult
      self
    end
  end

  class GreenDiv < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Div"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedDiv.new(self, parent, position)
    end
  end

  class RedDiv < RedGreen::SyntaxNode
    def initialize(green : GreenDiv, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedDiv
      self
    end
  end

  class GreenMod < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Mod"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedMod.new(self, parent, position)
    end
  end

  class RedMod < RedGreen::SyntaxNode
    def initialize(green : GreenMod, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedMod
      self
    end
  end

  class GreenPow < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Pow"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedPow.new(self, parent, position)
    end
  end

  class RedPow < RedGreen::SyntaxNode
    def initialize(green : GreenPow, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedPow
      self
    end
  end

  class GreenLShift < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "LShift"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedLShift.new(self, parent, position)
    end
  end

  class RedLShift < RedGreen::SyntaxNode
    def initialize(green : GreenLShift, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedLShift
      self
    end
  end

  class GreenRShift < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "RShift"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedRShift.new(self, parent, position)
    end
  end

  class RedRShift < RedGreen::SyntaxNode
    def initialize(green : GreenRShift, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedRShift
      self
    end
  end

  class GreenBitOr < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "BitOr"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedBitOr.new(self, parent, position)
    end
  end

  class RedBitOr < RedGreen::SyntaxNode
    def initialize(green : GreenBitOr, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedBitOr
      self
    end
  end

  class GreenBitXor < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "BitXor"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedBitXor.new(self, parent, position)
    end
  end

  class RedBitXor < RedGreen::SyntaxNode
    def initialize(green : GreenBitXor, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedBitXor
      self
    end
  end

  class GreenBitAnd < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "BitAnd"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedBitAnd.new(self, parent, position)
    end
  end

  class RedBitAnd < RedGreen::SyntaxNode
    def initialize(green : GreenBitAnd, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedBitAnd
      self
    end
  end

  class GreenFloorDiv < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "FloorDiv"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedFloorDiv.new(self, parent, position)
    end
  end

  class RedFloorDiv < RedGreen::SyntaxNode
    def initialize(green : GreenFloorDiv, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedFloorDiv
      self
    end
  end

  class GreenInvert < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Invert"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedInvert.new(self, parent, position)
    end
  end

  class RedInvert < RedGreen::SyntaxNode
    def initialize(green : GreenInvert, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedInvert
      self
    end
  end

  class GreenNot < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Not"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedNot.new(self, parent, position)
    end
  end

  class RedNot < RedGreen::SyntaxNode
    def initialize(green : GreenNot, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedNot
      self
    end
  end

  class GreenUAdd < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "UAdd"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedUAdd.new(self, parent, position)
    end
  end

  class RedUAdd < RedGreen::SyntaxNode
    def initialize(green : GreenUAdd, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedUAdd
      self
    end
  end

  class GreenUSub < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "USub"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedUSub.new(self, parent, position)
    end
  end

  class RedUSub < RedGreen::SyntaxNode
    def initialize(green : GreenUSub, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedUSub
      self
    end
  end

  class GreenEq < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Eq"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedEq.new(self, parent, position)
    end
  end

  class RedEq < RedGreen::SyntaxNode
    def initialize(green : GreenEq, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedEq
      self
    end
  end

  class GreenNotEq < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "NotEq"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedNotEq.new(self, parent, position)
    end
  end

  class RedNotEq < RedGreen::SyntaxNode
    def initialize(green : GreenNotEq, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedNotEq
      self
    end
  end

  class GreenLt < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Lt"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedLt.new(self, parent, position)
    end
  end

  class RedLt < RedGreen::SyntaxNode
    def initialize(green : GreenLt, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedLt
      self
    end
  end

  class GreenLtE < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "LtE"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedLtE.new(self, parent, position)
    end
  end

  class RedLtE < RedGreen::SyntaxNode
    def initialize(green : GreenLtE, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedLtE
      self
    end
  end

  class GreenGt < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Gt"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedGt.new(self, parent, position)
    end
  end

  class RedGt < RedGreen::SyntaxNode
    def initialize(green : GreenGt, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedGt
      self
    end
  end

  class GreenGtE < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "GtE"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedGtE.new(self, parent, position)
    end
  end

  class RedGtE < RedGreen::SyntaxNode
    def initialize(green : GreenGtE, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedGtE
      self
    end
  end

  class GreenIs < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "Is"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedIs.new(self, parent, position)
    end
  end

  class RedIs < RedGreen::SyntaxNode
    def initialize(green : GreenIs, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedIs
      self
    end
  end

  class GreenIsNot < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "IsNot"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedIsNot.new(self, parent, position)
    end
  end

  class RedIsNot < RedGreen::SyntaxNode
    def initialize(green : GreenIsNot, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedIsNot
      self
    end
  end

  class GreenIn < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "In"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedIn.new(self, parent, position)
    end
  end

  class RedIn < RedGreen::SyntaxNode
    def initialize(green : GreenIn, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedIn
      self
    end
  end

  class GreenNotIn < RedGreen::GreenNode
    def initialize
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "NotIn"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedNotIn.new(self, parent, position)
    end
  end

  class RedNotIn < RedGreen::SyntaxNode
    def initialize(green : GreenNotIn, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def update : RedNotIn
      self
    end
  end

  class Greencomprehension < RedGreen::GreenNode
    getter target : RedGreen::GreenNode
    getter iter : RedGreen::GreenNode
    getter ifs : RedGreen::InternalSyntax::SyntaxList

    def initialize(target : RedGreen::GreenNode, iter : RedGreen::GreenNode, ifs : RedGreen::InternalSyntax::SyntaxList)
      @target = target
      @iter = iter
      @ifs = ifs
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= target.flags
      full_width += target.full_width
      flags |= iter.flags
      full_width += iter.full_width
      flags |= ifs.flags
      full_width += ifs.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 3)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "comprehension"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        target
      when 1
        iter
      when 2
        ifs
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      Redcomprehension.new(self, parent, position)
    end
  end

  class Redcomprehension < RedGreen::SyntaxNode
    def initialize(green : Greencomprehension, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def target : RedGreen::SyntaxNode?
      child_at(0)
    end

    def iter : RedGreen::SyntaxNode?
      child_at(1)
    end

    def ifs : RedGreen::ChildSyntaxList
      list = @green.as(Greencomprehension).ifs
      RedGreen::SyntaxListNode.new(list, self, child_position(2)).child_nodes
    end

    def update(target : RedGreen::SyntaxNode, iter : RedGreen::SyntaxNode, ifs : Array(RedGreen::SyntaxNode)) : Redcomprehension
      return self if target == target && iter == iter && ifs == ifs.to_a
      green = Greencomprehension.new(target.green, iter.green, RedGreen::InternalSyntax::SyntaxList.new(ifs.map(&.green)))
      green.create_red(@parent, @position).as(Redcomprehension)
    end

    def with_target(target : RedGreen::SyntaxNode) : Redcomprehension
      update(target, iter, ifs.to_a)
    end

    def with_iter(iter : RedGreen::SyntaxNode) : Redcomprehension
      update(target, iter, ifs.to_a)
    end

    def with_ifs(ifs : Array(RedGreen::SyntaxNode)) : Redcomprehension
      update(target, iter, ifs)
    end
  end

  class GreenExceptHandler < RedGreen::GreenNode
    getter type : RedGreen::GreenNode?
    getter name : String?
    getter body : RedGreen::InternalSyntax::SyntaxList

    def initialize(type : RedGreen::GreenNode?, name : String?, body : RedGreen::InternalSyntax::SyntaxList)
      @type = type
      @name = name
      @body = body
      flags = RedGreen::NodeFlags::None
      full_width = 0
      if type
        flags |= type.flags
        full_width += type.full_width
      end
      flags |= body.flags
      full_width += body.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "ExceptHandler"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        type
      when 1
        body
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      RedExceptHandler.new(self, parent, position)
    end
  end

  class RedExceptHandler < RedGreen::SyntaxNode
    def initialize(green : GreenExceptHandler, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def type : RedGreen::SyntaxNode?
      child_at(0)
    end

    def name : String?
      @green.as(GreenExceptHandler).name
    end

    def body : RedGreen::ChildSyntaxList
      list = @green.as(GreenExceptHandler).body
      RedGreen::SyntaxListNode.new(list, self, child_position(1)).child_nodes
    end

    def update(type : RedGreen::SyntaxNode?, name : String?, body : Array(RedGreen::SyntaxNode)) : RedExceptHandler
      return self if type == type && name == name && body == body.to_a
      green = GreenExceptHandler.new(type.try(&.green), name, RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)))
      green.create_red(@parent, @position).as(RedExceptHandler)
    end

    def with_type(type : RedGreen::SyntaxNode?) : RedExceptHandler
      update(type, name, body.to_a)
    end

    def with_name(name : String?) : RedExceptHandler
      update(type, name, body.to_a)
    end

    def with_body(body : Array(RedGreen::SyntaxNode)) : RedExceptHandler
      update(type, name, body)
    end
  end

  class Greenarguments < RedGreen::GreenNode
    getter args : RedGreen::InternalSyntax::SyntaxList
    getter vararg : RedGreen::GreenNode?
    getter kwonlyargs : RedGreen::InternalSyntax::SyntaxList
    getter kw_defaults : RedGreen::InternalSyntax::SyntaxList
    getter kwarg : RedGreen::GreenNode?
    getter defaults : RedGreen::InternalSyntax::SyntaxList

    def initialize(args : RedGreen::InternalSyntax::SyntaxList, vararg : RedGreen::GreenNode?, kwonlyargs : RedGreen::InternalSyntax::SyntaxList, kw_defaults : RedGreen::InternalSyntax::SyntaxList, kwarg : RedGreen::GreenNode?, defaults : RedGreen::InternalSyntax::SyntaxList)
      @args = args
      @vararg = vararg
      @kwonlyargs = kwonlyargs
      @kw_defaults = kw_defaults
      @kwarg = kwarg
      @defaults = defaults
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= args.flags
      full_width += args.full_width
      if vararg
        flags |= vararg.flags
        full_width += vararg.full_width
      end
      flags |= kwonlyargs.flags
      full_width += kwonlyargs.full_width
      flags |= kw_defaults.flags
      full_width += kw_defaults.full_width
      if kwarg
        flags |= kwarg.flags
        full_width += kwarg.full_width
      end
      flags |= defaults.flags
      full_width += defaults.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 6)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "arguments"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        args
      when 1
        vararg
      when 2
        kwonlyargs
      when 3
        kw_defaults
      when 4
        kwarg
      when 5
        defaults
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      Redarguments.new(self, parent, position)
    end
  end

  class Redarguments < RedGreen::SyntaxNode
    def initialize(green : Greenarguments, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def args : RedGreen::ChildSyntaxList
      list = @green.as(Greenarguments).args
      RedGreen::SyntaxListNode.new(list, self, child_position(0)).child_nodes
    end

    def vararg : RedGreen::SyntaxNode?
      child_at(1)
    end

    def kwonlyargs : RedGreen::ChildSyntaxList
      list = @green.as(Greenarguments).kwonlyargs
      RedGreen::SyntaxListNode.new(list, self, child_position(2)).child_nodes
    end

    def kw_defaults : RedGreen::ChildSyntaxList
      list = @green.as(Greenarguments).kw_defaults
      RedGreen::SyntaxListNode.new(list, self, child_position(3)).child_nodes
    end

    def kwarg : RedGreen::SyntaxNode?
      child_at(4)
    end

    def defaults : RedGreen::ChildSyntaxList
      list = @green.as(Greenarguments).defaults
      RedGreen::SyntaxListNode.new(list, self, child_position(5)).child_nodes
    end

    def update(args : Array(RedGreen::SyntaxNode), vararg : RedGreen::SyntaxNode?, kwonlyargs : Array(RedGreen::SyntaxNode), kw_defaults : Array(RedGreen::SyntaxNode), kwarg : RedGreen::SyntaxNode?, defaults : Array(RedGreen::SyntaxNode)) : Redarguments
      return self if args == args.to_a && vararg == vararg && kwonlyargs == kwonlyargs.to_a && kw_defaults == kw_defaults.to_a && kwarg == kwarg && defaults == defaults.to_a
      green = Greenarguments.new(RedGreen::InternalSyntax::SyntaxList.new(args.map(&.green)), vararg.try(&.green), RedGreen::InternalSyntax::SyntaxList.new(kwonlyargs.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(kw_defaults.map(&.green)), kwarg.try(&.green), RedGreen::InternalSyntax::SyntaxList.new(defaults.map(&.green)))
      green.create_red(@parent, @position).as(Redarguments)
    end

    def with_args(args : Array(RedGreen::SyntaxNode)) : Redarguments
      update(args, vararg, kwonlyargs.to_a, kw_defaults.to_a, kwarg, defaults.to_a)
    end

    def with_vararg(vararg : RedGreen::SyntaxNode?) : Redarguments
      update(args.to_a, vararg, kwonlyargs.to_a, kw_defaults.to_a, kwarg, defaults.to_a)
    end

    def with_kwonlyargs(kwonlyargs : Array(RedGreen::SyntaxNode)) : Redarguments
      update(args.to_a, vararg, kwonlyargs, kw_defaults.to_a, kwarg, defaults.to_a)
    end

    def with_kw_defaults(kw_defaults : Array(RedGreen::SyntaxNode)) : Redarguments
      update(args.to_a, vararg, kwonlyargs.to_a, kw_defaults, kwarg, defaults.to_a)
    end

    def with_kwarg(kwarg : RedGreen::SyntaxNode?) : Redarguments
      update(args.to_a, vararg, kwonlyargs.to_a, kw_defaults.to_a, kwarg, defaults.to_a)
    end

    def with_defaults(defaults : Array(RedGreen::SyntaxNode)) : Redarguments
      update(args.to_a, vararg, kwonlyargs.to_a, kw_defaults.to_a, kwarg, defaults)
    end
  end

  class Greenarg < RedGreen::GreenNode
    getter arg : String
    getter annotation_ : RedGreen::GreenNode?

    def initialize(arg : String, annotation_ : RedGreen::GreenNode?)
      @arg = arg
      @annotation_ = annotation_
      flags = RedGreen::NodeFlags::None
      full_width = 0
      if annotation_
        flags |= annotation_.flags
        full_width += annotation_.full_width
      end
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "arg"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        annotation_
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      Redarg.new(self, parent, position)
    end
  end

  class Redarg < RedGreen::SyntaxNode
    def initialize(green : Greenarg, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def arg : String
      @green.as(Greenarg).arg
    end

    def annotation_ : RedGreen::SyntaxNode?
      child_at(0)
    end

    def update(arg : String, annotation_ : RedGreen::SyntaxNode?) : Redarg
      return self if arg == arg && annotation_ == annotation_
      green = Greenarg.new(arg, annotation_.try(&.green))
      green.create_red(@parent, @position).as(Redarg)
    end

    def with_arg(arg : String) : Redarg
      update(arg, annotation_)
    end

    def with_annotation_(annotation_ : RedGreen::SyntaxNode?) : Redarg
      update(arg, annotation_)
    end
  end

  class Greenkeyword < RedGreen::GreenNode
    getter arg : String
    getter value : RedGreen::GreenNode

    def initialize(arg : String, value : RedGreen::GreenNode)
      @arg = arg
      @value = value
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= value.flags
      full_width += value.full_width
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 1)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "keyword"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        value
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      Redkeyword.new(self, parent, position)
    end
  end

  class Redkeyword < RedGreen::SyntaxNode
    def initialize(green : Greenkeyword, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def arg : String
      @green.as(Greenkeyword).arg
    end

    def value : RedGreen::SyntaxNode?
      child_at(0)
    end

    def update(arg : String, value : RedGreen::SyntaxNode) : Redkeyword
      return self if arg == arg && value == value
      green = Greenkeyword.new(arg, value.green)
      green.create_red(@parent, @position).as(Redkeyword)
    end

    def with_arg(arg : String) : Redkeyword
      update(arg, value)
    end

    def with_value(value : RedGreen::SyntaxNode) : Redkeyword
      update(arg, value)
    end
  end

  class Greenalias < RedGreen::GreenNode
    getter name : String
    getter asname : String?

    def initialize(name : String, asname : String?)
      @name = name
      @asname = asname
      flags = RedGreen::NodeFlags::None
      full_width = 0
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 0)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "alias"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      Redalias.new(self, parent, position)
    end
  end

  class Redalias < RedGreen::SyntaxNode
    def initialize(green : Greenalias, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def name : String
      @green.as(Greenalias).name
    end

    def asname : String?
      @green.as(Greenalias).asname
    end

    def update(name : String, asname : String?) : Redalias
      return self if name == name && asname == asname
      green = Greenalias.new(name, asname)
      green.create_red(@parent, @position).as(Redalias)
    end

    def with_name(name : String) : Redalias
      update(name, asname)
    end

    def with_asname(asname : String?) : Redalias
      update(name, asname)
    end
  end

  class Greenwithitem < RedGreen::GreenNode
    getter context_expr : RedGreen::GreenNode
    getter optional_vars : RedGreen::GreenNode?

    def initialize(context_expr : RedGreen::GreenNode, optional_vars : RedGreen::GreenNode?)
      @context_expr = context_expr
      @optional_vars = optional_vars
      flags = RedGreen::NodeFlags::None
      full_width = 0
      flags |= context_expr.flags
      full_width += context_expr.full_width
      if optional_vars
        flags |= optional_vars.flags
        full_width += optional_vars.full_width
      end
      packed = RedGreen::GreenNode.pack_flags_and_slot_count(flags, 2)
      super(0_u16, packed, full_width)
    end

    def language : String
      ""
    end

    def kind_text : String
      "withitem"
    end

    def token? : Bool
      false
    end

    def trivia? : Bool
      false
    end

    def get_slot(index : Int32) : RedGreen::GreenNode?
      case index
      when 0
        context_expr
      when 1
        optional_vars
      end
    end

    def create_red(parent : RedGreen::SyntaxNode?, position : Int32) : RedGreen::SyntaxNode | RedGreen::SyntaxToken | RedGreen::SyntaxTrivia
      Redwithitem.new(self, parent, position)
    end
  end

  class Redwithitem < RedGreen::SyntaxNode
    def initialize(green : Greenwithitem, parent : RedGreen::SyntaxNode?, position : Int32)
      super(green, parent, position, parent.try(&.syntax_tree))
    end

    def context_expr : RedGreen::SyntaxNode?
      child_at(0)
    end

    def optional_vars : RedGreen::SyntaxNode?
      child_at(1)
    end

    def update(context_expr : RedGreen::SyntaxNode, optional_vars : RedGreen::SyntaxNode?) : Redwithitem
      return self if context_expr == context_expr && optional_vars == optional_vars
      green = Greenwithitem.new(context_expr.green, optional_vars.try(&.green))
      green.create_red(@parent, @position).as(Redwithitem)
    end

    def with_context_expr(context_expr : RedGreen::SyntaxNode) : Redwithitem
      update(context_expr, optional_vars)
    end

    def with_optional_vars(optional_vars : RedGreen::SyntaxNode?) : Redwithitem
      update(context_expr, optional_vars)
    end
  end

  module Factory
    def self.make_module(body : Array(RedGreen::SyntaxNode)) : RedModule
      green = GreenModule.new(RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)))
      green.create_red(nil, 0).as(RedModule)
    end

    def self.make_interactive(body : Array(RedGreen::SyntaxNode)) : RedInteractive
      green = GreenInteractive.new(RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)))
      green.create_red(nil, 0).as(RedInteractive)
    end

    def self.make_expression(body : RedGreen::SyntaxNode) : RedExpression
      green = GreenExpression.new(body.green)
      green.create_red(nil, 0).as(RedExpression)
    end

    def self.make_suite(body : Array(RedGreen::SyntaxNode)) : RedSuite
      green = GreenSuite.new(RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)))
      green.create_red(nil, 0).as(RedSuite)
    end

    def self.make_function_def(name : String, args : RedGreen::SyntaxNode, body : Array(RedGreen::SyntaxNode), decorator_list : Array(RedGreen::SyntaxNode), returns : RedGreen::SyntaxNode?) : RedFunctionDef
      green = GreenFunctionDef.new(name, args.green, RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(decorator_list.map(&.green)), returns.try(&.green))
      green.create_red(nil, 0).as(RedFunctionDef)
    end

    def self.make_class_def(name : String, bases : Array(RedGreen::SyntaxNode), keywords : Array(RedGreen::SyntaxNode), starargs : RedGreen::SyntaxNode?, kwargs : RedGreen::SyntaxNode?, body : Array(RedGreen::SyntaxNode), decorator_list : Array(RedGreen::SyntaxNode)) : RedClassDef
      green = GreenClassDef.new(name, RedGreen::InternalSyntax::SyntaxList.new(bases.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(keywords.map(&.green)), starargs.try(&.green), kwargs.try(&.green), RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(decorator_list.map(&.green)))
      green.create_red(nil, 0).as(RedClassDef)
    end

    def self.make_return(value : RedGreen::SyntaxNode?) : RedReturn
      green = GreenReturn.new(value.try(&.green))
      green.create_red(nil, 0).as(RedReturn)
    end

    def self.make_delete(targets : Array(RedGreen::SyntaxNode)) : RedDelete
      green = GreenDelete.new(RedGreen::InternalSyntax::SyntaxList.new(targets.map(&.green)))
      green.create_red(nil, 0).as(RedDelete)
    end

    def self.make_assign(targets : Array(RedGreen::SyntaxNode), value : RedGreen::SyntaxNode) : RedAssign
      green = GreenAssign.new(RedGreen::InternalSyntax::SyntaxList.new(targets.map(&.green)), value.green)
      green.create_red(nil, 0).as(RedAssign)
    end

    def self.make_aug_assign(target : RedGreen::SyntaxNode, op : RedGreen::SyntaxNode, value : RedGreen::SyntaxNode) : RedAugAssign
      green = GreenAugAssign.new(target.green, op.green, value.green)
      green.create_red(nil, 0).as(RedAugAssign)
    end

    def self.make_for(target : RedGreen::SyntaxNode, iter : RedGreen::SyntaxNode, body : Array(RedGreen::SyntaxNode), orelse : Array(RedGreen::SyntaxNode)) : RedFor
      green = GreenFor.new(target.green, iter.green, RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(orelse.map(&.green)))
      green.create_red(nil, 0).as(RedFor)
    end

    def self.make_while(test : RedGreen::SyntaxNode, body : Array(RedGreen::SyntaxNode), orelse : Array(RedGreen::SyntaxNode)) : RedWhile
      green = GreenWhile.new(test.green, RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(orelse.map(&.green)))
      green.create_red(nil, 0).as(RedWhile)
    end

    def self.make_if(test : RedGreen::SyntaxNode, body : Array(RedGreen::SyntaxNode), orelse : Array(RedGreen::SyntaxNode)) : RedIf
      green = GreenIf.new(test.green, RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(orelse.map(&.green)))
      green.create_red(nil, 0).as(RedIf)
    end

    def self.make_with(items : Array(RedGreen::SyntaxNode), body : Array(RedGreen::SyntaxNode)) : RedWith
      green = GreenWith.new(RedGreen::InternalSyntax::SyntaxList.new(items.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)))
      green.create_red(nil, 0).as(RedWith)
    end

    def self.make_raise(exc : RedGreen::SyntaxNode?, cause : RedGreen::SyntaxNode?) : RedRaise
      green = GreenRaise.new(exc.try(&.green), cause.try(&.green))
      green.create_red(nil, 0).as(RedRaise)
    end

    def self.make_try(body : Array(RedGreen::SyntaxNode), handlers : Array(RedGreen::SyntaxNode), orelse : Array(RedGreen::SyntaxNode), finalbody : Array(RedGreen::SyntaxNode)) : RedTry
      green = GreenTry.new(RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(handlers.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(orelse.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(finalbody.map(&.green)))
      green.create_red(nil, 0).as(RedTry)
    end

    def self.make_assert(test : RedGreen::SyntaxNode, msg : RedGreen::SyntaxNode?) : RedAssert
      green = GreenAssert.new(test.green, msg.try(&.green))
      green.create_red(nil, 0).as(RedAssert)
    end

    def self.make_import(names : Array(RedGreen::SyntaxNode)) : RedImport
      green = GreenImport.new(RedGreen::InternalSyntax::SyntaxList.new(names.map(&.green)))
      green.create_red(nil, 0).as(RedImport)
    end

    def self.make_import_from(module_ : String?, names : Array(RedGreen::SyntaxNode), level : Int32?) : RedImportFrom
      green = GreenImportFrom.new(module_, RedGreen::InternalSyntax::SyntaxList.new(names.map(&.green)), level)
      green.create_red(nil, 0).as(RedImportFrom)
    end

    def self.make_global(names : Array(String)) : RedGlobal
      green = GreenGlobal.new(names)
      green.create_red(nil, 0).as(RedGlobal)
    end

    def self.make_nonlocal(names : Array(String)) : RedNonlocal
      green = GreenNonlocal.new(names)
      green.create_red(nil, 0).as(RedNonlocal)
    end

    def self.make_expr(value : RedGreen::SyntaxNode) : RedExpr
      green = GreenExpr.new(value.green)
      green.create_red(nil, 0).as(RedExpr)
    end

    def self.make_pass : RedPass
      green = GreenPass.new
      green.create_red(nil, 0).as(RedPass)
    end

    def self.make_break : RedBreak
      green = GreenBreak.new
      green.create_red(nil, 0).as(RedBreak)
    end

    def self.make_continue : RedContinue
      green = GreenContinue.new
      green.create_red(nil, 0).as(RedContinue)
    end

    def self.make_bool_op(op : RedGreen::SyntaxNode, values : Array(RedGreen::SyntaxNode)) : RedBoolOp
      green = GreenBoolOp.new(op.green, RedGreen::InternalSyntax::SyntaxList.new(values.map(&.green)))
      green.create_red(nil, 0).as(RedBoolOp)
    end

    def self.make_bin_op(left : RedGreen::SyntaxNode, op : RedGreen::SyntaxNode, right : RedGreen::SyntaxNode) : RedBinOp
      green = GreenBinOp.new(left.green, op.green, right.green)
      green.create_red(nil, 0).as(RedBinOp)
    end

    def self.make_unary_op(op : RedGreen::SyntaxNode, operand : RedGreen::SyntaxNode) : RedUnaryOp
      green = GreenUnaryOp.new(op.green, operand.green)
      green.create_red(nil, 0).as(RedUnaryOp)
    end

    def self.make_lambda(args : RedGreen::SyntaxNode, body : RedGreen::SyntaxNode) : RedLambda
      green = GreenLambda.new(args.green, body.green)
      green.create_red(nil, 0).as(RedLambda)
    end

    def self.make_if_exp(test : RedGreen::SyntaxNode, body : RedGreen::SyntaxNode, orelse : RedGreen::SyntaxNode) : RedIfExp
      green = GreenIfExp.new(test.green, body.green, orelse.green)
      green.create_red(nil, 0).as(RedIfExp)
    end

    def self.make_dict(keys : Array(RedGreen::SyntaxNode), values : Array(RedGreen::SyntaxNode)) : RedDict
      green = GreenDict.new(RedGreen::InternalSyntax::SyntaxList.new(keys.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(values.map(&.green)))
      green.create_red(nil, 0).as(RedDict)
    end

    def self.make_set(elts : Array(RedGreen::SyntaxNode)) : RedSet
      green = GreenSet.new(RedGreen::InternalSyntax::SyntaxList.new(elts.map(&.green)))
      green.create_red(nil, 0).as(RedSet)
    end

    def self.make_list_comp(elt : RedGreen::SyntaxNode, generators : Array(RedGreen::SyntaxNode)) : RedListComp
      green = GreenListComp.new(elt.green, RedGreen::InternalSyntax::SyntaxList.new(generators.map(&.green)))
      green.create_red(nil, 0).as(RedListComp)
    end

    def self.make_set_comp(elt : RedGreen::SyntaxNode, generators : Array(RedGreen::SyntaxNode)) : RedSetComp
      green = GreenSetComp.new(elt.green, RedGreen::InternalSyntax::SyntaxList.new(generators.map(&.green)))
      green.create_red(nil, 0).as(RedSetComp)
    end

    def self.make_dict_comp(key : RedGreen::SyntaxNode, value : RedGreen::SyntaxNode, generators : Array(RedGreen::SyntaxNode)) : RedDictComp
      green = GreenDictComp.new(key.green, value.green, RedGreen::InternalSyntax::SyntaxList.new(generators.map(&.green)))
      green.create_red(nil, 0).as(RedDictComp)
    end

    def self.make_generator_exp(elt : RedGreen::SyntaxNode, generators : Array(RedGreen::SyntaxNode)) : RedGeneratorExp
      green = GreenGeneratorExp.new(elt.green, RedGreen::InternalSyntax::SyntaxList.new(generators.map(&.green)))
      green.create_red(nil, 0).as(RedGeneratorExp)
    end

    def self.make_yield(value : RedGreen::SyntaxNode?) : RedYield
      green = GreenYield.new(value.try(&.green))
      green.create_red(nil, 0).as(RedYield)
    end

    def self.make_yield_from(value : RedGreen::SyntaxNode) : RedYieldFrom
      green = GreenYieldFrom.new(value.green)
      green.create_red(nil, 0).as(RedYieldFrom)
    end

    def self.make_compare(left : RedGreen::SyntaxNode, ops : Array(RedGreen::SyntaxNode), comparators : Array(RedGreen::SyntaxNode)) : RedCompare
      green = GreenCompare.new(left.green, RedGreen::InternalSyntax::SyntaxList.new(ops.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(comparators.map(&.green)))
      green.create_red(nil, 0).as(RedCompare)
    end

    def self.make_call(func : RedGreen::SyntaxNode, args : Array(RedGreen::SyntaxNode), keywords : Array(RedGreen::SyntaxNode), starargs : RedGreen::SyntaxNode?, kwargs : RedGreen::SyntaxNode?) : RedCall
      green = GreenCall.new(func.green, RedGreen::InternalSyntax::SyntaxList.new(args.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(keywords.map(&.green)), starargs.try(&.green), kwargs.try(&.green))
      green.create_red(nil, 0).as(RedCall)
    end

    def self.make_num(n : String) : RedNum
      green = GreenNum.new(n)
      green.create_red(nil, 0).as(RedNum)
    end

    def self.make_str(s : String) : RedStr
      green = GreenStr.new(s)
      green.create_red(nil, 0).as(RedStr)
    end

    def self.make_bytes(s : String) : RedBytes
      green = GreenBytes.new(s)
      green.create_red(nil, 0).as(RedBytes)
    end

    def self.make_name_constant(value : Bool) : RedNameConstant
      green = GreenNameConstant.new(value)
      green.create_red(nil, 0).as(RedNameConstant)
    end

    def self.make_ellipsis : RedEllipsis
      green = GreenEllipsis.new
      green.create_red(nil, 0).as(RedEllipsis)
    end

    def self.make_attribute(value : RedGreen::SyntaxNode, attr : String, ctx : RedGreen::SyntaxNode) : RedAttribute
      green = GreenAttribute.new(value.green, attr, ctx.green)
      green.create_red(nil, 0).as(RedAttribute)
    end

    def self.make_subscript(value : RedGreen::SyntaxNode, slice : RedGreen::SyntaxNode, ctx : RedGreen::SyntaxNode) : RedSubscript
      green = GreenSubscript.new(value.green, slice.green, ctx.green)
      green.create_red(nil, 0).as(RedSubscript)
    end

    def self.make_starred(value : RedGreen::SyntaxNode, ctx : RedGreen::SyntaxNode) : RedStarred
      green = GreenStarred.new(value.green, ctx.green)
      green.create_red(nil, 0).as(RedStarred)
    end

    def self.make_name(id : String, ctx : RedGreen::SyntaxNode) : RedName
      green = GreenName.new(id, ctx.green)
      green.create_red(nil, 0).as(RedName)
    end

    def self.make_list(elts : Array(RedGreen::SyntaxNode), ctx : RedGreen::SyntaxNode) : RedList
      green = GreenList.new(RedGreen::InternalSyntax::SyntaxList.new(elts.map(&.green)), ctx.green)
      green.create_red(nil, 0).as(RedList)
    end

    def self.make_tuple(elts : Array(RedGreen::SyntaxNode), ctx : RedGreen::SyntaxNode) : RedTuple
      green = GreenTuple.new(RedGreen::InternalSyntax::SyntaxList.new(elts.map(&.green)), ctx.green)
      green.create_red(nil, 0).as(RedTuple)
    end

    def self.make_load : RedLoad
      green = GreenLoad.new
      green.create_red(nil, 0).as(RedLoad)
    end

    def self.make_store : RedStore
      green = GreenStore.new
      green.create_red(nil, 0).as(RedStore)
    end

    def self.make_del : RedDel
      green = GreenDel.new
      green.create_red(nil, 0).as(RedDel)
    end

    def self.make_aug_load : RedAugLoad
      green = GreenAugLoad.new
      green.create_red(nil, 0).as(RedAugLoad)
    end

    def self.make_aug_store : RedAugStore
      green = GreenAugStore.new
      green.create_red(nil, 0).as(RedAugStore)
    end

    def self.make_param : RedParam
      green = GreenParam.new
      green.create_red(nil, 0).as(RedParam)
    end

    def self.make_slice(lower : RedGreen::SyntaxNode?, upper : RedGreen::SyntaxNode?, step : RedGreen::SyntaxNode?) : RedSlice
      green = GreenSlice.new(lower.try(&.green), upper.try(&.green), step.try(&.green))
      green.create_red(nil, 0).as(RedSlice)
    end

    def self.make_ext_slice(dims : Array(RedGreen::SyntaxNode)) : RedExtSlice
      green = GreenExtSlice.new(RedGreen::InternalSyntax::SyntaxList.new(dims.map(&.green)))
      green.create_red(nil, 0).as(RedExtSlice)
    end

    def self.make_index(value : RedGreen::SyntaxNode) : RedIndex
      green = GreenIndex.new(value.green)
      green.create_red(nil, 0).as(RedIndex)
    end

    def self.make_and : RedAnd
      green = GreenAnd.new
      green.create_red(nil, 0).as(RedAnd)
    end

    def self.make_or : RedOr
      green = GreenOr.new
      green.create_red(nil, 0).as(RedOr)
    end

    def self.make_add : RedAdd
      green = GreenAdd.new
      green.create_red(nil, 0).as(RedAdd)
    end

    def self.make_sub : RedSub
      green = GreenSub.new
      green.create_red(nil, 0).as(RedSub)
    end

    def self.make_mult : RedMult
      green = GreenMult.new
      green.create_red(nil, 0).as(RedMult)
    end

    def self.make_div : RedDiv
      green = GreenDiv.new
      green.create_red(nil, 0).as(RedDiv)
    end

    def self.make_mod : RedMod
      green = GreenMod.new
      green.create_red(nil, 0).as(RedMod)
    end

    def self.make_pow : RedPow
      green = GreenPow.new
      green.create_red(nil, 0).as(RedPow)
    end

    def self.make_lhift : RedLShift
      green = GreenLShift.new
      green.create_red(nil, 0).as(RedLShift)
    end

    def self.make_rhift : RedRShift
      green = GreenRShift.new
      green.create_red(nil, 0).as(RedRShift)
    end

    def self.make_bit_or : RedBitOr
      green = GreenBitOr.new
      green.create_red(nil, 0).as(RedBitOr)
    end

    def self.make_bit_xor : RedBitXor
      green = GreenBitXor.new
      green.create_red(nil, 0).as(RedBitXor)
    end

    def self.make_bit_and : RedBitAnd
      green = GreenBitAnd.new
      green.create_red(nil, 0).as(RedBitAnd)
    end

    def self.make_floor_div : RedFloorDiv
      green = GreenFloorDiv.new
      green.create_red(nil, 0).as(RedFloorDiv)
    end

    def self.make_invert : RedInvert
      green = GreenInvert.new
      green.create_red(nil, 0).as(RedInvert)
    end

    def self.make_not : RedNot
      green = GreenNot.new
      green.create_red(nil, 0).as(RedNot)
    end

    def self.make_udd : RedUAdd
      green = GreenUAdd.new
      green.create_red(nil, 0).as(RedUAdd)
    end

    def self.make_uub : RedUSub
      green = GreenUSub.new
      green.create_red(nil, 0).as(RedUSub)
    end

    def self.make_eq : RedEq
      green = GreenEq.new
      green.create_red(nil, 0).as(RedEq)
    end

    def self.make_not_eq : RedNotEq
      green = GreenNotEq.new
      green.create_red(nil, 0).as(RedNotEq)
    end

    def self.make_lt : RedLt
      green = GreenLt.new
      green.create_red(nil, 0).as(RedLt)
    end

    def self.make_lt_e : RedLtE
      green = GreenLtE.new
      green.create_red(nil, 0).as(RedLtE)
    end

    def self.make_gt : RedGt
      green = GreenGt.new
      green.create_red(nil, 0).as(RedGt)
    end

    def self.make_gt_e : RedGtE
      green = GreenGtE.new
      green.create_red(nil, 0).as(RedGtE)
    end

    def self.make_is : RedIs
      green = GreenIs.new
      green.create_red(nil, 0).as(RedIs)
    end

    def self.make_is_not : RedIsNot
      green = GreenIsNot.new
      green.create_red(nil, 0).as(RedIsNot)
    end

    def self.make_in : RedIn
      green = GreenIn.new
      green.create_red(nil, 0).as(RedIn)
    end

    def self.make_not_in : RedNotIn
      green = GreenNotIn.new
      green.create_red(nil, 0).as(RedNotIn)
    end

    def self.make_comprehension(target : RedGreen::SyntaxNode, iter : RedGreen::SyntaxNode, ifs : Array(RedGreen::SyntaxNode)) : Redcomprehension
      green = Greencomprehension.new(target.green, iter.green, RedGreen::InternalSyntax::SyntaxList.new(ifs.map(&.green)))
      green.create_red(nil, 0).as(Redcomprehension)
    end

    def self.make_except_handler(type : RedGreen::SyntaxNode?, name : String?, body : Array(RedGreen::SyntaxNode)) : RedExceptHandler
      green = GreenExceptHandler.new(type.try(&.green), name, RedGreen::InternalSyntax::SyntaxList.new(body.map(&.green)))
      green.create_red(nil, 0).as(RedExceptHandler)
    end

    def self.make_arguments(args : Array(RedGreen::SyntaxNode), vararg : RedGreen::SyntaxNode?, kwonlyargs : Array(RedGreen::SyntaxNode), kw_defaults : Array(RedGreen::SyntaxNode), kwarg : RedGreen::SyntaxNode?, defaults : Array(RedGreen::SyntaxNode)) : Redarguments
      green = Greenarguments.new(RedGreen::InternalSyntax::SyntaxList.new(args.map(&.green)), vararg.try(&.green), RedGreen::InternalSyntax::SyntaxList.new(kwonlyargs.map(&.green)), RedGreen::InternalSyntax::SyntaxList.new(kw_defaults.map(&.green)), kwarg.try(&.green), RedGreen::InternalSyntax::SyntaxList.new(defaults.map(&.green)))
      green.create_red(nil, 0).as(Redarguments)
    end

    def self.make_arg(arg : String, annotation_ : RedGreen::SyntaxNode?) : Redarg
      green = Greenarg.new(arg, annotation_.try(&.green))
      green.create_red(nil, 0).as(Redarg)
    end

    def self.make_keyword(arg : String, value : RedGreen::SyntaxNode) : Redkeyword
      green = Greenkeyword.new(arg, value.green)
      green.create_red(nil, 0).as(Redkeyword)
    end

    def self.make_alias(name : String, asname : String?) : Redalias
      green = Greenalias.new(name, asname)
      green.create_red(nil, 0).as(Redalias)
    end

    def self.make_withitem(context_expr : RedGreen::SyntaxNode, optional_vars : RedGreen::SyntaxNode?) : Redwithitem
      green = Greenwithitem.new(context_expr.green, optional_vars.try(&.green))
      green.create_red(nil, 0).as(Redwithitem)
    end
  end
end
